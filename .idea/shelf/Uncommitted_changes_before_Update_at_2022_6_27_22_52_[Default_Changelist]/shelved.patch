Index: docs/pages/Back-end/_sidebar.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n* [主页](/README)\r\n\r\n* [后端相关](pages/Back-end/READE)\r\n\r\n \r\n* [Java](pages/Back-end/Java/README)\r\n\r\n\t* [定时任务 - Timer](pages/Back-end/Java/定时任务/TimeTask-java-timer  \"TimeTask-java-timer\")\r\n\t* [定时任务 - Task](pages/Back-end/Java/定时任务/TimeTask-spring-task-1  \"TimeTask-spring-task\")\r\n\t* [定时任务 - Quartz](pages/Back-end/Java/定时任务/TimeTask-quartz  \"TimeTask-quartz\")\r\n\r\n* [JUC](pages/Back-end/JUC/README)\r\n\r\n\t* [JUC 基本概念](pages/Back-end/JUC/Juc-01)\r\n\t* [并发-多线程](pages/Back-end/JUC/Juc-02-threads)\r\n\t* [并发-三大问题](pages/Back-end/JUC/Juc-03-lilun)\r\n\r\n\r\n* MySQL\r\n\t* [MySQL5 在线安装](pages/Back-end/MySQL/mysql-01-install)\r\n\t* [MySQL5 解压安装](pages/Back-end/MySQL/mysql-02-install)\r\n\t* [MySQL8 解压安装](pages/Back-end/MySQL/MySQL8-800-setup)\r\n\t* [MySQL Engine](pages/Back-end/MySQL/MySQL-100-Engine)\r\n\t* [MySQL Index](pages/Back-end/MySQL/MySQL-110-Index)\r\n\t* [MySQL Explain](pages/Back-end/MySQL/MySQL-120-Explain)\r\n\t* [MySQL 命令](pages/Back-end/MySQL/Mysql-command)\r\n\t* [MySQL 登录异常](pages/Back-end/MySQL/Mysql-login)\r\n\r\n* [Spring](pages/Back-end/Spring/README  \"Spring\")\r\n\r\n\t* [Spring-IoC](pages/Back-end/Spring/Spring-001-IoC  \"Spring IoC\")\r\n\t* [Spring-AOP](pages/Back-end/Spring/Spring-002-Aop  \"Spring Aop\")\r\n \t\r\n\t* [Spring-事务失效](pages/Back-end/Spring/Spring-transactional-invalid  \"Spring 事务失效\")\r\n \r\n\t* [Spring-Batch](pages/Back-end/Spring/spring-batch  \"Spring 批处理框架\")\r\n\r\n* [SpringBoot ](pages/Back-end/SpringBoot/README  \"SpringBoot\")\r\n\r\n\t* [SpringBoot 自动装配](pages/Back-end/SpringBoot/SpringBoot-200-autoconfig  \"AutoConfig\")\r\n\r\n\t* [SpringBoot YAML](pages/Back-end/SpringBoot/springboot-100-yaml  \"YAML\")\r\n\t\r\n\t* [SpringBoot Log](pages/Back-end/SpringBoot/springboot-120-log  \"Log\")\r\n\r\n\t* [SpringBoot Thymeleaf](pages/Back-end/SpringBoot/springboot-140-thymeleaf  \"Thymeleaf\")\r\n\r\n\t* [SpringBoot Thymeleaf 内置对象](pages/Back-end/SpringBoot/springboot-141-thymeleaf-in-object  \"Thymeleaf 内置对象\")\r\n\r\n\t* [SpringBoot Profile](pages/Back-end/SpringBoot/springboot-160-config  \"Config\")\r\n\r\n\t* [SpringBoot Cache](pages/Back-end/SpringBoot/springboot-170-cache  \"Cache\")\r\n\r\n\t* [SpringBoot 注解](pages/Back-end/SpringBoot/springboot-180-annotation  \"注解\")\r\n\t* [SpringBoot 注解IoC](pages/Back-end/SpringBoot/springboot-150-ioc-20200814  \"注解IoC\")\r\n\r\n\t* [SpringBoot Jackson](pages/Back-end/SpringBoot/SpringBoot-190-jackson  \"jackson\")\r\n\r\n\t\r\n\t\r\n* SpringCloud\t\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/pages/Back-end/_sidebar.md	(revision 640356315098df147a918066267421cc14c29e2c)
+++ docs/pages/Back-end/_sidebar.md	(date 1612755413026)
@@ -3,18 +3,20 @@
 
 * [后端相关](pages/Back-end/READE)
 
- 
+
 * [Java](pages/Back-end/Java/README)
 
 	* [定时任务 - Timer](pages/Back-end/Java/定时任务/TimeTask-java-timer  "TimeTask-java-timer")
 	* [定时任务 - Task](pages/Back-end/Java/定时任务/TimeTask-spring-task-1  "TimeTask-spring-task")
 	* [定时任务 - Quartz](pages/Back-end/Java/定时任务/TimeTask-quartz  "TimeTask-quartz")
+	* [JAVA IO](pages/Back-end/Java/IO/Java-IO  "Java-IO")
 
 * [JUC](pages/Back-end/JUC/README)
 
 	* [JUC 基本概念](pages/Back-end/JUC/Juc-01)
 	* [并发-多线程](pages/Back-end/JUC/Juc-02-threads)
 	* [并发-三大问题](pages/Back-end/JUC/Juc-03-lilun)
+	* [Volatile](pages/Back-end/JUC/Juc-04-volatile)
 
 
 * MySQL
@@ -31,9 +33,9 @@
 
 	* [Spring-IoC](pages/Back-end/Spring/Spring-001-IoC  "Spring IoC")
 	* [Spring-AOP](pages/Back-end/Spring/Spring-002-Aop  "Spring Aop")
- 	
+
 	* [Spring-事务失效](pages/Back-end/Spring/Spring-transactional-invalid  "Spring 事务失效")
- 
+
 	* [Spring-Batch](pages/Back-end/Spring/spring-batch  "Spring 批处理框架")
 
 * [SpringBoot ](pages/Back-end/SpringBoot/README  "SpringBoot")
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n# 前言   <!-- {docsify-ignore} -->\r\n\r\n\r\n　　已经有博客了，为什么还要搞个文档库？依赖是这种文档式结构在检索上比博客看上去更适合查资料，如果你博客内容比较多时，你不一定记得自己原来整理过什么，文档化就是为了更快捷的查询想要的内容。同时文档化就是典型的知识分区，知识树形化，也让自己加深印象。\r\n\r\n\r\n# Small-Docs <!-- {docsify-ignore} -->\r\n\r\n　　这是一个供我自己使用的个人知识库，仅仅为了把自己的学习的知识进行归纳整理，可以方便自己查阅使用的。\r\n\r\n\u200B\t\t没想好项目叫什么，暂时就叫它 **Small-Docs** 。\r\n\r\n　　如果你也想做一个，参考 >> [docsify](https://docsify.js.org/#/zh-cn/)\r\n\r\n# 主页\r\n\r\n- https://zhangxiaocai.cn
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- README.md	(revision 640356315098df147a918066267421cc14c29e2c)
+++ README.md	(date 1656149898419)
@@ -1,3 +1,10 @@
+
+# 前言   <!-- {docsify-ignore} -->
+
+
+　　已经有博客了，为什么还要搞个文档库？依赖是这种文档式结构在检索上比博客看上去更适合查资料，如果你博客内容比较多时，你不一定记得自己原来整理过什么，文档化就是为了更快捷的查询想要的内容。同时文档化就是典型的知识分区，知识树形化，也让自己加深印象。
+
+
 
 # 前言   <!-- {docsify-ignore} -->
 
@@ -9,10 +16,11 @@
 
 　　这是一个供我自己使用的个人知识库，仅仅为了把自己的学习的知识进行归纳整理，可以方便自己查阅使用的。
 
-​		没想好项目叫什么，暂时就叫它 **Small-Docs** 。
+​	 没想好项目叫什么，暂时就叫它 **Small-Docs** 。
 
 　　如果你也想做一个，参考 >> [docsify](https://docsify.js.org/#/zh-cn/)
 
 # 主页
 
+- https://small-role.github.io
 - https://zhangxiaocai.cn
\ No newline at end of file
Index: docs/pages/Back-end/Java/定时任务/TimeTask-quartz.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 定时任务之Quartz\r\ntags:\r\n  - Quartz\r\ncategories: 定时任务\r\nsummary: 本文整理quartz的不同场景不同用法。\r\nkeywords: 'java,sql,quartz定时任务,Quartz 定时任务,cron表达式'\r\nauthor: Small-Rose / 张小菜\r\nabbrlink: 6ddb3c14\r\ndate: 2020-07-18 23:00:00\r\nupdate: 2020-07-18 21:00:00\r\n---\r\n\r\n> 本文主要记录学习Quartz的相关内容。\r\n  整理于2020-06-25，最后更新2020-07-18。\r\n\r\n\r\n\r\n### 一、Quartz简述\r\n\r\n关于调度的实现方式主要有三种：\r\n\r\n（1）Java自带的Api有个Timer类和TimerTask类。\r\n\r\n（2）Spring自带的Spring Task调度工具。\r\n\r\n（3）Quartz（读阔子）开源框架，功能强大，使用起来稍显复杂。\r\n\r\n\r\n\r\n> Quartz是一个完全由java编写的开源作业调度框架，由OpenSymphony组织开源出来。作业调度其实就是按照程序的设定，根据定义的执行时间频次表达去执行某个作业任务。\r\n\r\n之前说过一个定时任务的基本组件有：执行的任务类、触发任务的触发器、管理任务的任务调度器。\r\n\r\n那么Quartz同样有这三个基本的组件，但是除此之外还有更丰富的组件。在`Quartz-2.0`之后增加了构造器模式创建示例，监听器的集中管理接口等内容，所以有些地方在写法上稍有不同。\r\n\r\n\r\n\r\n\r\n### 二、Quartz的基本组件\r\n\r\n#### 1、Scheduler调度器\r\n\r\n`Scheduler`在使用之前需要实例化。一般通过调度工厂`SchedulerFactory`来创建一个实例。\r\n\r\n```java\r\n//得到一个默认的调度工厂\r\nSchedulerFactory schedulerFactory = new StdSchedulerFactory\r\nScheduler sched = schedFact.getScheduler();\r\n```\r\n\r\n`scheduler`实例化后，可以启动(start)、暂停(stand-by)、停止(shutdown)、还可以设置自定义相关监听。\r\n\r\n【注意，此处只是列出一些常见方法，实际使用先后顺序】\r\n\r\n```java\r\nscheduler.scheduleJob(jobDetail, simpleTrigger);//添加调度任务\r\n\r\nscheduler.start();  //启动\r\nscheduler.standby(); //暂停\r\nscheduler.shutdown();//关闭\r\n\r\nscheduler.addJobListener(new UpJobListener()); //添加自定义任务执行监听\r\nscheduler.addTriggerListener(new UpTriggerListener()); //添加自定义触发器监听\r\nscheduler.addSchedulerListener(new UpSchedulerListener()); //添加自定义调度器监听\r\n```\r\n\r\n\u200B\t需要注意的是：scheduler被停止后，除非重新实例化，否则不能重新启动；只有当scheduler启动后，即使处于暂停状态也不行，trigger才会被触发（job才能被执行）。\r\n\r\n\u200B       Quartz-2.0之后的监听器调整为使用监听管理的`ListenerManager`接口进行集中管理的。使用添加或移除都需要先拿到`ListenerManager`之后再进行操作，后面会有具体示例。\r\n\r\n#### 2、Job作业接口\r\n\r\nJob接口只有一个execute方法，类似线程的run方法，用来执行业务作业逻辑。\r\n\r\n业务作业实现了Job接口之后就可以由调度器Schedule进行管理执行。\r\n\r\n```java\r\npackage com.smallrose.web.app.quartz.job;\r\n\r\nimport org.quartz.Job;\r\nimport org.quartz.JobDataMap;\r\nimport org.quartz.JobExecutionContext;\r\nimport org.quartz.JobExecutionException;\r\n\r\npublic class TestJob implements Job {\r\n\r\n\t@Override\r\n\tpublic void execute(JobExecutionContext context) throws JobExecutionException {\r\n\t\tJobDataMap dataMap = context.getJobDetail().getJobDataMap();\r\n        System.out.println(\" job executed \" + dataMap);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n#### 3、JobDetail作业实例\r\n\r\n`JobDetail`用于定义作业的实例（Job实例），为Job实例提供属性设置，用来存储特定Job实例的状态信息，调度器Schedule需要借助`JobDetail`对象来添加Job实例。\r\n\r\n`JobDetail`的重要属性有：\r\n\r\n\u200B\t`name`---- 任务名称\r\n\r\n\u200B\t`group` ---- 任务所在组名称\r\n\r\n\u200B\t`jobClass` ---- 任务执行类，也就是实现了`Job`接口的业务作业类。\r\n\r\n\u200B\t`jobDataMap` ---- 任务的状态数据，其实就是一些相关参数，可以动态传入。\r\n\r\n```java\r\nMap<String,Object> map = new HashMap<Srting,Object>();\r\nJobDetail JobDetail = new JobDetail(jobName, jobGroupName, jobClass);\r\nJobDetail.getJobDataMap().put(\"data\", map);\r\n// 该数据可以通过Job中的JobDataMap dataMap = context.getJobDetail().getJobDataMap();来进行参数传递值\r\n```\r\n\r\n\r\n\r\n#### 4、Trigger触发器\r\n\r\nTrigger是用来定义执行业务作业的计划组件。\r\n\r\nTrigger的类型主要有4种：\r\n\r\n\u200B\t（1）`SimpleTrigger`：从某一个时间开始，以一定的时间间隔来执行任务。它主要有两个属性，`repeatInterval` 重复的时间间隔；`repeatCount` 重复的次数，实际上执行的次数是n+1,因为在`startTime`的时候会执行一次。\r\n\r\n\u200B\t（2） `CronTrigger `：适合于复杂的任务，使用`cron`表达式来定义执行规则。\r\n\r\n\u200B\t（3）`CalendarIntervalTrigger`：类似于`SimpleTrigger`，指定从某一个时间开始，以一定的时间间隔执行的任务。但是`CalendarIntervalTrigger`执行任务的时间间隔比`SimpleTrigger`要丰富，它支持的间隔单位有秒，分钟，小时，天，月，年，星期。它的主要两个属性，`interval`执行间隔；`intervalUnit `执行间隔的单位（秒，分钟，小时，天，月，年，星期）\r\n\r\n相较于`SimpleTrigger`有两个优势：\r\n\r\n1、更方便，比如每隔1小时执行，不用自己去计算1小时等于多少毫秒。\r\n2、支持不是固定长度的间隔，比如间隔为月和年。但劣势是精度只能到秒。\r\n\r\n\u200B\t（4）`DailyTimeIntervalTrigger`：指定每天的某个时间段内，以一定的时间间隔执行任务。并且它可以支持指定星期。\r\n\r\n它适合的任务类似于：指定每天9:00 至 18:00，每隔70秒执行一次，并且只要周一至周五执行。\r\n\r\n它的属性有`startTimeOfDay `每天开始时间；`endTimeOfDay `每天结束时间；`daysOfWeek `需要执行的星期；`interval` 执行间隔；`intervalUnit `执行间隔的单位（秒，分钟，小时，天，月，年，星期）；`repeatCount `重复次数\r\n\r\n\r\n\r\nTrigger公共属性主要有：\r\n\r\n`jobKey`属性，当触发器触发时被执行的job定位；\r\n\r\n`startTime`属性：设置Trigger第一次触发的时间；\r\n\r\n`endTime`属性：表示Trigger失效的时间点。\r\n\r\n优先级(priority)、错过触发(misfire)、日历(calendar)等\r\n\r\n\u200B\t优先级（priority）\r\n\r\n>Quartz线程池的工作线程太少或者触发器较多时，Quartz可能没有足够的资源同时触发所有的trigger；这种情况下，你可能希望控制哪些trigger优先使用Quartz的工作线程，要达到该目的，可以在trigger上设置priority属性。\r\n>\r\n>注意：只有同时触发的trigger之间才会比较优先级。比如：11:59触发的trigger总是在12:00触发的trigger之前执行。\r\n>\r\n>注意：如果trigger是可恢复的，在恢复后再调度时，优先级与原trigger是一样的。\r\n\r\n```java\r\nSimpleTrigger simpleTrigger = new SimpleTrigger(triggerName, triggerGroupName);\r\nsimpleTrigger.setStartTime(new Date());\r\n\r\n// set the interval, how often the job should run (10 seconds here) \r\nsimpleTrigger.setRepeatInterval(3000); //执行间隔毫秒\r\n    \r\nsimpleTrigger.setRepeatCount(10);//重复执行次数（不含第一次执行）\r\n\r\n//结束时间\r\nsimpleTrigger.setEndTime(new Date(ctime + 60000L));\r\n// 设置触发器的优先级 默认是 5\r\nsimpleTrigger.setPriority(10);\r\n```\r\n\r\n\r\n\r\n\u200B\t错过触发（misfire）\r\n\r\n>如果scheduler关闭了（系统崩溃），或者Quartz线程池中没有可用的线程来执行job（任务时间过长），此时持久性的trigger就会错过(miss)其触发时间，即错过触发(misfire)。\r\n>\r\n>不同类型的trigger，有不同的misfire机制。它们默认都使用“智能机制(smart policy)”，即根据trigger的类型和配置动态调整行为。当scheduler启动的时候，查询所有错过触发(misfire)的持久性trigger。然后根据它们各自的misfire机制更新trigger的信息。\r\n\r\n\r\n\r\n\u200B\t日历（Calendar）\r\n\r\n> Quartz的`org.quartz.Calendar`对象(不是`java.util.Calendar`对象)可以在定义和存储trigger的时候与trigger进行关联。Calendar用于从trigger的调度计划中排除时间段。比如，可以创建一个trigger，每个工作日的上午9:30执行，然后增加一个Calendar，排除掉所有节假日。\r\n>\r\n> 任何实现了Calendar接口的可序列化对象都可以作为Calendar对象。一个Trigger可以和多个Calendar关联，以便排除或包含某些时间点。\r\n\r\n```java\r\npackage org.quartz;\r\n\r\npublic interface Calendar {\r\n  //参数是毫秒单位的时间戳\r\n  public boolean isTimeIncluded(long timeStamp);\r\n  public long getNextIncludedTime(long timeStamp);\r\n\r\n}\r\n```\r\n\r\nQuartz提供的`org.quartz.impl.HolidayCalendar`类可以很方便地实现排除整个日期。\r\n\r\n```java\r\nHolidayCalendar cal = new HolidayCalendar();\r\ncal.addExcludedDate( someDate );\r\ncal.addExcludedDate( someOtherDate );\r\n\r\nscheduler.addCalendar(\"myHolidaysName\", cal, false);\r\n\r\n\r\nTrigger t = newTrigger()\r\n    .withIdentity(\"myTriggerName\")\r\n    .forJob(\"myJobName\")\r\n    .withSchedule(dailyAtHourAndMinute(9, 30)) // execute job daily at 9:30\r\n    .modifiedByCalendar(\"myHolidaysName\") // but not on holidays\r\n    .build();\r\n```\r\n\r\n只要的日历类有：\r\n\r\n| 日历类          | 说明                                                         |\r\n| --------------- | ------------------------------------------------------------ |\r\n| HolidayCalendar | 指定特定的日期，比如20200613。精度到天。                     |\r\n| DailyCalendar   | 指定每天的时间段（rangeStartingTime, rangeEndingTime)，格式是HH:MM[:SS[:mmm]]。也就是最大精度可以到毫秒。 |\r\n| WeeklyCalendar  | 指定每星期的星期几，可选值比如为java.util.Calendar.SUNDAY。精度是天。 |\r\n| MonthlyCalendar | 指定每月的几号。可选值为1-31。精度是天                       |\r\n| AnnualCalendar  | 指定每年的哪一天。使用方式如上例。精度是天。                 |\r\n| CronCalendar    | 指定`Cron`表达式。精度取决于`Cron`表达式，也就是最大精度可以到秒。 |\r\n\r\n\r\n\r\n#### 5、JobBuilder构造器\r\n\r\n[注意：版本较低的可能没有构造器方式，即可能没有`JobBuilder`、`TriggerBuilder`等Builder模式]\r\n\r\n`JobBuilder`也是用于定义/构建`JobDetail`实例，定义作业的实例。`JobBuilder`的属性和`JobDetail`的属性基本一致，这样得以在build()方法里面，完成对`JobDetail`进行创建。是一个构造器风格的API。\r\n\r\n```java\r\nJobDetail job = newJob(MyJob.class)\r\n             .withIdentity(\"myJob\")\r\n             .build();\r\n             \r\nTrigger trigger = newTrigger() \r\n             .withIdentity(triggerKey(\"myTrigger\", \"myTriggerGroup\"))\r\n             .withSchedule(simpleSchedule()\r\n             .withIntervalInHours(1)\r\n             .repeatForever())\r\n             .startAt(futureDate(10, MINUTES))\r\n             .build();\r\n         \r\nscheduler.scheduleJob(job, trigger);\r\n```\r\n\r\n#### 6、TriggerBuilder构造器\r\n\r\n`TriggerBuilder`  用于定义/构建触发器实例。是一个构造器风格的API。\r\n\r\n```java\r\nJobDetail job = newJob(TestJob.class)\r\n             .withIdentity(\"myJob\")\r\n             .build();\r\n             \r\nTrigger trigger = newTrigger() \r\n             .withIdentity(triggerKey(\"myTrigger\", \"myTriggerGroup\"))\r\n             .withSchedule(simpleSchedule()\r\n             .withIntervalInHours(1)\r\n             .repeatForever())\r\n             .startAt(futureDate(10, MINUTES))\r\n             .build();\r\n         \r\nscheduler.scheduleJob(job, trigger);\r\n```\r\n\r\n\r\n\r\n### 三、触发器使用\r\n\r\n\u200B\t前面学习了不同的Trigger，常用2种是：`SimpleTrigger`和 `CronTrigger `。\r\n\r\n#### 1、SimpleTrigger\r\n\r\n简易触发器的使用场景是：在具体的时间点执行一次，或者在具体的时间点执行并且以指定的间隔重复执行若干次。\r\n\r\n`SimpleTrigger`的属性包括：开始时间、结束时间、重复次数以及重复的间隔。\r\n\r\n重复次数，可以是0、正整数，以及常量`SimpleTrigger.REPEAT_INDEFINITELY`。\r\n\r\n重复的间隔，必须是0，或者long型的正数，表示毫秒。注意:，如果重复间隔为0，trigger将会以重复次数并发执行(或者以scheduler可以处理的近似并发数)。\r\n\r\nendTime属性的值会覆盖设置重复次数的属性值；比如，你可以创建一个trigger，在终止时间之前每隔10秒执行一次，你不需要去计算在开始时间和终止时间之间的重复次数，只需要设置终止时间并将重复次数设置为REPEAT_INDEFINITELY(当然，你也可以将重复次数设置为一个很大的值，并保证该值比trigger在终止时间之前实际触发的次数要大即可)。\r\n\r\n##### 构建SimpleTrigger\r\n\r\n`SimpleTrigger`实例通过`TriggerBuilder`设置主要的属性，通过`SimpleScheduleBuilder`设置与`SimpleTrigger`相关的属性。要使用这些builder的静态方法，需要静态导入：\r\n\r\n```java\r\nimport static org.quartz.TriggerBuilder.*;\r\nimport static org.quartz.SimpleScheduleBuilder.*;\r\nimport static org.quartz.DateBuilder.*:\r\n```\r\n\r\n##### 常见的触发实例：\r\n\r\n如：指定时间开始触发，不重复：\r\n\r\n```java\r\nScheduler scheduler = schedulerFactory.getScheduler();\r\n\t\t \r\nDate someDate = new Date().from(Instant.now().plusSeconds(30));\r\n\t\t\r\nSimpleTrigger simpleTrigger =  (SimpleTrigger)newTrigger()\r\n        .withIdentity(\"trigger1\", \"group1\")\r\n        .startAt(someDate)        // some Date \r\n        .forJob(\"job1\", \"group1\")  // identify job with name, group strings\r\n        .build();\r\n```\r\n\r\n指定时间触发，每隔10秒执行一次，重复10次：\r\n\r\n```java\r\nsimpleTrigger =  (SimpleTrigger)newTrigger()\r\n        .withIdentity(\"trigger2\", \"group1\")\r\n        .startAt(myTimeToStartFiring)  // if a start time is not given (if this line were omitted), \"now\" is implied\r\n        .withSchedule(simpleSchedule()\r\n        .withIntervalInSeconds(10)\r\n         .withRepeatCount(10)) // note that 10 repeats will give a total of 11 firings\r\n        .forJob(myJob) // identify job with handle to its JobDetail itself             \r\n        .build();\r\n```\r\n\r\n5分钟以后开始触发，仅执行一次：\r\n\r\n```java\r\nsimpleTrigger =  (SimpleTrigger)newTrigger()\r\n        .withIdentity(\"trigger3\", \"group1\")\r\n        .startAt(futureDate(5, IntervalUnit.MINUTE)) // use DateBuilder to create a date in the future\r\n        .forJob(myJobKey) // identify job with its JobKey\r\n        .build();\r\n```\r\n\r\n立即触发，每个5分钟执行一次，直到22:00：\r\n\r\n```java\r\nsimpleTrigger =  (SimpleTrigger)newTrigger()\r\n        .withIdentity(\"trigger4\", \"group1\")\r\n        .withSchedule(simpleSchedule()\r\n            .withIntervalInMinutes(5)\r\n            .repeatForever())\r\n        .endAt(dateOf(22, 0, 0))\r\n        .build();\r\n```\r\n\r\n在下一小时整点触发，每个2小时执行一次，一直重复：\r\n\r\n```java\r\nsimpleTrigger =  (SimpleTrigger)newTrigger()\r\n        .withIdentity(\"trigger5\") // 没有定义组名，\"trigger5\"进入默认的group\r\n        .startAt(evenHourDate(null)) //整点触发 (minutes and seconds zero (\"00:00\"))\r\n        .withSchedule(simpleSchedule()\r\n        .withIntervalInHours(2)\r\n        .repeatForever())//一直重复\r\n        // note that in this example, 'forJob(..)' is not called which is valid \r\n        // if the trigger is passed to the scheduler along with the job  \r\n        .build();\r\n\r\nscheduler.scheduleJob(trigger, job);\r\n```\r\n\r\n还有一些没有列举的方法，在实际使用中可以点开代码看。\r\n\r\n> TriggerBuilder(以及Quartz的其它builder)会为那些没有被显式设置的属性选择合理的默认值。比如：如果你没有调用*withIdentity(..)*方法，TriggerBuilder会为trigger生成一个随机的名称；如果没有调用*startAt(..)*方法，则默认使用当前时间，即trigger立即生效。\r\n\r\n\r\n\r\n**`SimpleTrigger` Misfire策略：**\r\n\r\n所有的trigger都有一个Trigger.MISFIRE_INSTRUCTION_SMART_POLICY策略可以使用，该策略也是所有trigger的默认策略。对于`SimpleTrigger`，这个“智能机制”将根据触发器实例的状态和配置来决定其行为。具体如下：\r\n\r\n如果Repeat Count=0：只执行一次　\r\n\r\n\u200B\t instruction selected = MISFIRE_INSTRUCTION_FIRE_NOW;\r\n\r\n如果Repeat Count=REPEAT_INDEFINITELY：无限次执行\r\n\r\n\u200B\tinstruction selected = MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT;\r\n\r\n如果Repeat Count>0：执行多次（有限）\r\n\r\n　　instruction selected = MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT;\r\n\r\n\r\n\r\n`SimpleTrigger`常见策略：\r\n\r\n| 常见策略                                                 | 策略说明                                               |\r\n| -------------------------------------------------------- | ------------------------------------------------------ |\r\n| MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY                | 忽略所有的超时状态，按照触发器的策略执行。             |\r\n| MISFIRE_INSTRUCTION_FIRE_NOW                             | 立刻执行。对于不会重复执行的任务，这是默认的处理策略。 |\r\n| MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT | 在下一个激活点执行，且超时期内错过的执行机会作废。     |\r\n| MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_COUNT  | 立即执行，且超时期内错过的执行机会作废。               |\r\n| MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT  | 在下一个激活点执行，并重复到指定的次数。               |\r\n| MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_COUNT   | 立即执行，并重复到指定的次数。                         |\r\n| MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY                | 忽略所有的超时状态，按照触发器的策略执行。             |\r\n\r\n\r\n\r\n#### 2、CronTrigger \r\n\r\n`Cron`表达式触发器的使用场景是：\r\n\r\n基于时间表，在复杂的时间点，复杂的执行周期执行一次或多次。\r\n\r\n例如：“每周一到周五上午8:00”或“每月最后一个星期五凌晨1:30”。 \r\n\r\n `CronTrigger `类似于在给定的时间触发作业，和Linux的“`cron-like`”调度定义相似。“`Cron Expression`”字符串的格式记录在`CronExpression`类中。\r\n\r\n##### Cron Expressions\r\n\r\n`Cron-Expressions`用于配置`CronTrigger`的实例。`Cron Expressions`是由七个子表达式组成的字符串，用于描述日程表的各个细节。这些子表达式用空格分隔，七个子表达式依次为：` 秒 分 时 日 月 周 年`\r\n\r\n| 位置 | 说明         | 允许值 | 特殊值                             |\r\n| ---- | ------------ | ------ | ---------------------------------- |\r\n| 1    | Seconds      | 0-59   | `,`  `-` `*`  `/`                  |\r\n| 2    | Minutes      | 0-59   | `,`  `-` `*`  `/`                  |\r\n| 3    | Hours        | 0-23   | `,`  `-` `*`  `/`                  |\r\n| 4    | Day-of-Month | 1-31   | `,`  `-` `*`  `/` `?`  `L` `W` `C` |\r\n| 5    | Month        | 1-12   | `,`  `-` `*`  `/`                  |\r\n| 6    | Day-of-Week  | 1-7    | `,`  `-` `*`  `/` `?` `L` `C` `#`  |\r\n| 7    | Year (可选)  |        | `,`  `-` `*`  `/`                  |\r\n\r\n`Cron`表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感。\r\n\r\n特殊符号说明：\r\n\r\n| 符号 | 说明 |\r\n| ---- | ---- |\r\n|**星号(\\*)**|可用在所有字段中，表示对应时间域的每一个时刻，例如，* 在分钟字段时，表示“每分钟”；|\r\n|**问号（?）**|该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于占位符；|\r\n|**减号(-)**|表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；|\r\n|**逗号(,)**|表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；|\r\n|**斜杠(/)**|x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y；|\r\n|**L** &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|该字符只在日期和星期字段中使用，代表“Last”的意思，但它在两个字段中意思不同。<br/>L在日期字段中，表示这个月份的最后一天，如一月的31号，非闰年二月的28号；<br/>如果L用在星期中，则表示星期六，等同于7。<br/>但是，如果L出现在星期字段里，而且在前面有一个数值X，则表示“这个月的最后X天”，例如，6L表示该月的最后星期五；|\r\n|**W**|该字符只能出现在日期字段里，是对前导日期的修饰，表示离该日期最近的工作日。<br/>例如15W表示离该月15号最近的工作日，如果该月15号是星期六，则匹配14号星期五；如果15日是星期日，则匹配16号星期一；如果15号是星期二，那结果就是15号星期二。但必须注意关联的匹配日期不能够跨月，如你指定1W，如果1号是星期六，结果匹配的是3号星期一，而非上个月最后的那天。W字符串只能指定单一日期，而不能指定日期范围；|\r\n|**LW组合**|在日期字段可以组合使用LW，它的意思是当月的最后一个工作日；|\r\n|**井号(#) **|该字符只能在星期字段中使用，表示当月某个工作日。如6#3表示当月的第三个星期五(6表示星期五，#3表示当前的第三个)，而4#5表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发；|\r\n|**C **|该字符只在日期和星期字段中使用，代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如5C在日期字段中就相当于日历5日以后的第一天。1C在星期字段中相当于星期日后的第一天。|\r\n\r\n##### 常见表达式示例：\r\n\r\n| 表达式                       | 含义                                                         |\r\n| ---------------------------- | ------------------------------------------------------------ |\r\n| `\"0 0 12 * * ?\"`             | 每天12点触发执行                                             |\r\n| `\"0 15 10 ? * *\"`            | 每天10点15分触发执行                                         |\r\n| `\"0 15 10 * * ?\"`            | 每天10点15分触发执行                                         |\r\n| `\"0 15 10 * * ? *\"`          | 每天10点15分触发执行                                         |\r\n| `\"0 15 10 * * ? 2020\"`       | 在2020年内，每天10点15分触发执行                             |\r\n| `\"0 * 14 * * ?\"`             | 每天从下午2点开始到下午2点59分结束，每分钟触发执行一次       |\r\n| `\"0 0/5 14 * * ?\"`           | 每天从下午2点到下午2点55分，每5分钟触发一次                  |\r\n| `\"0 0/5 14,18 * * ?\"`        | 每天从下午2点开始到下午2点55分每5分钟触发一次<br/>从下午6点开始到下午6点55分结束，每5分钟触发一次 |\r\n| `\"0 0-5 14 * * ?\"`           | 每天从下午2点开始到下午2点05分结束，每分钟触发一次           |\r\n| `\"0 10,44 14 ? 3 WED\"`       | （每年）三月每周三下午2:10和2:44触发                         |\r\n| `\"0 15 10 ? * MON-FRI\"`      | 每周一、二、三、四、五上午10:15触发                          |\r\n| `\"0 15 10 15 * ?\"`           | 每月15日上午10:15触发                                        |\r\n| `\"0 15 10 L * ?\"`            | 每月最后一天上午10:15触发                                    |\r\n| `\"0 15 10 * ？ 6L\"`          | 每月最后一个星期五上午10:15触发                              |\r\n| `\"0 15 10 ? * 6L\"`           | 每月最后一个星期五上午10:15触发                              |\r\n| `\"0 15 10 ? * 6L 2012-2015\"` | 在 2012, 2013, 2014,2015期间，每月最后一个星期五上午10:15触发 |\r\n| `\"0 15 10 ? * 6#3\"`          | 每月第三个星期五上午10:15触发执行                            |\r\n\r\n\r\n\r\n##### 构建CronTriggers\r\n\r\n`CronTrigger`实例使用`TriggerBuilder`（用于触发器的主要属性）和`CronScheduleBuilder`（对于`CronTrigger`特定的属性）构建。要以`DSL`风格使用这些构建器，请使用静态导入：\r\n\r\n```\r\nimport static org.quartz.TriggerBuilder.*;\r\nimport static org.quartz.CronScheduleBuilder.*;\r\nimport static org.quartz.DateBuilder.*:\r\n```\r\n\r\n建立一个触发器，每隔一分钟，每天上午8点至下午5点之间：\r\n\r\n```\r\nCronTrigger cronTrigger = newTrigger()\r\n\t\t\t\t.withIdentity(\"trigger3\", \"triggerGroupName\")\r\n\t\t\t    .withSchedule(cronSchedule(\"0 0/2 8-17 * * ?\"))\r\n\t\t\t    .forJob(\"myJobName\", \"groupName\").build();\r\n```\r\n\r\n建立一个触发器，将在上午10:42每天发射：\r\n\r\n```\r\nCronTrigger cronTrigger = newTrigger()\r\n    .withIdentity(\"trigger3\", \"triggerGroupName\")\r\n    .withSchedule(dailyAtHourAndMinute(10, 42))\r\n    .forJob(myJobKey)\r\n    .build();\r\n```\r\n\r\n或者：\r\n\r\n```\r\nCronTrigger cronTrigger = newTrigger()\r\n    .withIdentity(\"trigger3\", \"triggerGroupName\")\r\n    .withSchedule(cronSchedule(\"0 42 10 * * ?\"))\r\n    .forJob(myJobKey)\r\n    .build();\r\n```\r\n\r\n建立一个带时区的触发器，将在星期三上午10:42在TimeZone（系统默认值）之外触发：\r\n\r\n```\r\n  trigger = newTrigger()\r\n    .withIdentity(\"trigger3\", \"triggerGroupName\")\r\n    .withSchedule(weeklyOnDayAndHourAndMinute(DateBuilder.WEDNESDAY, 10, 42))\r\n    .forJob(myJobKey)\r\n    .inTimeZone(TimeZone.getTimeZone(\"America/Los_Angeles\"))\r\n    .build();\r\n```\r\n\r\n或者：\r\n\r\n```\r\n  trigger = newTrigger()\r\n    .withIdentity(\"trigger3\", \"triggerGroupName\")\r\n    .withSchedule(cronSchedule(\"0 42 10 ? * WED\"))\r\n    .inTimeZone(TimeZone.getTimeZone(\"America/Los_Angeles\"))\r\n    .forJob(myJobKey)\r\n    .build();\r\n```\r\n\r\n##### CronTrigger Misfire说明\r\n\r\n\r\n\r\n##### CronTrigger常见策略：\r\n\r\n| 策略名称                                  | 策略说明                                                     |\r\n| ----------------------------------------- | ------------------------------------------------------------ |\r\n| MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY | 忽略所有的超时状态，按照触发器的策略执行。                   |\r\n| MISFIRE_INSTRUCTION_FIRE_ONCE_NOW         | 立刻执行一次，然后就按照正常的计划执行。                     |\r\n| MISFIRE_INSTRUCTION_DO_NOTHING            | 目前不执行，然后就按照正常的计划执行。这意味着如果下次执行时间超过了end time，实际上就没有执行机会了。 |\r\n\r\n所有的trigger都有一个Trigger.MISFIRE_INSTRUCTION_SMART_POLICY策略可以使用，该策略也是所有trigger的默认策略。对于`CronTrigger`，该“智能机制”默认选择`MISFIRE_INSTRUCTION_FIRE_ONCE_NOW`以指导其行为。\r\n\r\n>TriggerBuilder(以及Quartz的其它builder)会为那些没有被显式设置的属性选择合理的默认值。比如：如果你没有调用*withIdentity(..)*方法，TriggerBuilder会为trigger生成一个随机的名称；如果没有调用*startAt(..)*方法，则默认使用当前时间，即trigger立即生效。\r\n\r\n\r\n\r\n### 四、监听器使用\r\n\r\n\r\n\r\n**Listeners**(监听器)是实现监听接口创建的对象，用于根据调度程序中发生的事件执行操作。\r\n\r\n比较常用的监听器： \r\n\r\n#### 1. 触发器监听和任务执行监听\r\n\r\nTriggerListeners接收到与触发器（trigger）相关的事件，JobListeners 接收与jobs相关的事件。\r\n\r\n与触发相关的事件包括：触发器触发，触发失灵，并触发完成（触发器关闭的作业完成）。\r\n\r\n`org.quartz.TriggerListener`接口\r\n\r\n```java\r\npublic interface TriggerListener {\r\n\r\n    public String getName();\r\n\r\n    public void triggerFired(Trigger trigger, JobExecutionContext context);\r\n\r\n    public boolean vetoJobExecution(Trigger trigger, JobExecutionContext context);\r\n\r\n    public void triggerMisfired(Trigger trigger);\r\n\r\n    public void triggerComplete(Trigger trigger, JobExecutionContext context,\r\n            int triggerInstructionCode);\r\n}\r\n```\r\n\r\njob相关事件包括：job即将执行的通知，以及job完成执行时的通知。\r\n\r\norg.quartz.JobListener接口\r\n\r\n```java\r\npublic interface JobListener {\r\n\r\n    public String getName();\r\n\r\n    public void jobToBeExecuted(JobExecutionContext context);\r\n\r\n    public void jobExecutionVetoed(JobExecutionContext context);\r\n\r\n    public void jobWasExecuted(JobExecutionContext context,\r\n            JobExecutionException jobException);\r\n\r\n}\r\n```\r\n\r\n#### 2. 自定义监听器：\r\n\r\n要创建一个自定义的listener，只需创建一个实现`org.quartz.TriggerListener`或`org.quartz.JobListener`接口的对象。\r\n\r\n如自定义一个触发相关监听器：\r\n\r\n```ava\r\npackage com.smallrose.web.app.quartz.listener;\r\n\r\nimport org.quartz.JobExecutionContext;\r\nimport org.quartz.Trigger;\r\nimport org.quartz.Trigger.CompletedExecutionInstruction;\r\nimport org.quartz.TriggerListener;\r\n\r\npublic class TestTriggerListener implements TriggerListener {\r\n\r\n\t@Override\r\n\tpublic String getName() {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void triggerFired(Trigger trigger, JobExecutionContext context) {\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean vetoJobExecution(Trigger trigger, JobExecutionContext context) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void triggerMisfired(Trigger trigger) {\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void triggerComplete(Trigger trigger, JobExecutionContext context,\r\n\t\t\tCompletedExecutionInstruction triggerInstructionCode) {\r\n\r\n\t}\r\n}\r\n```\r\n\r\n如自定义一个任务相关监听器：\r\n\r\n```java\r\npackage com.smallrose.web.app.quartz.listener;\r\n\r\nimport org.quartz.JobExecutionContext;\r\nimport org.quartz.JobExecutionException;\r\nimport org.quartz.JobListener;\r\n\r\npublic class TestJobListener implements JobListener {\r\n\r\n\t@Override\r\n\tpublic String getName() {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void jobToBeExecuted(JobExecutionContext context) {\r\n        \r\n\t}\r\n\r\n\t@Override\r\n\tpublic void jobExecutionVetoed(JobExecutionContext context) {\r\n        \r\n\t}\r\n\r\n\t@Override\r\n\tpublic void jobWasExecuted(JobExecutionContext context, JobExecutionException jobException) {\r\n        \r\n\t}\r\n}\r\n```\r\n\r\n#### 3. 监听器的使用\r\n\r\n添加监听使用示例：\r\n\r\n```java\r\n//旧版\r\nscheduler.addJobListener(new UpJobListener()); //添加自定义任务执行监听\r\nscheduler.addTriggerListener(new UpTriggerListener()); //添加自定义触发器监听\r\n\r\n//新版 since 2.0\r\nscheduler.getListenerManager().addJobListener(new UpJobListener()); //添加任务执行监听\r\nscheduler.getListenerManager().addTriggerListener(new UpJobListener()); //添加任务执行触发器监听\r\n```\r\n\r\n移除监听使用示例：\r\n\r\n```java\r\nscheduler.removeJobListener(new UpJobListener()); //移除自定义任务执行监听\r\nscheduler.removeTriggerListener(new UpTriggerListener()); //移除自定义触发器监听\r\n```\r\n\r\n```\r\npackage org.quartz;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * \r\n * @author jhouse\r\n * @since 2.0 - previously listeners were managed directly on the Scheduler interface.\r\n */\r\npublic interface ListenerManager {\r\n\r\n    public void addJobListener(JobListener jobListener);\r\n\r\n    public void addJobListener(JobListener jobListener, Matcher<JobKey> matcher);\r\n\r\n    public void addJobListener(JobListener jobListener, Matcher<JobKey> ... matchers);\r\n\r\n    public void addJobListener(JobListener jobListener, List<Matcher<JobKey>> matchers);\r\n \r\n    public boolean addJobListenerMatcher(String listenerName, Matcher<JobKey> matcher);\r\n\r\n    public boolean removeJobListenerMatcher(String listenerName, Matcher<JobKey> matcher);\r\n\r\n    public boolean setJobListenerMatchers(String listenerName, List<Matcher<JobKey>> matchers);\r\n\r\n    public List<Matcher<JobKey>> getJobListenerMatchers(String listenerName);\r\n \r\n    public boolean removeJobListener(String name);\r\n \r\n    public JobListener getJobListener(String name);\r\n \r\n    public void addTriggerListener(TriggerListener triggerListener);\r\n    \r\n \r\n    public void addTriggerListener(TriggerListener triggerListener, Matcher<TriggerKey> matcher);\r\n    \r\n   \r\n    public void addTriggerListener(TriggerListener triggerListener, Matcher<TriggerKey> ... matchers);\r\n\r\n \r\n    public void addTriggerListener(TriggerListener triggerListener, List<Matcher<TriggerKey>> matchers);\r\n \r\n    public boolean addTriggerListenerMatcher(String listenerName, Matcher<TriggerKey> matcher);\r\n\r\n \r\n    public boolean removeTriggerListenerMatcher(String listenerName, Matcher<TriggerKey> matcher);\r\n\r\n \r\n    public boolean setTriggerListenerMatchers(String listenerName, List<Matcher<TriggerKey>> matchers);\r\n \r\n    public List<Matcher<TriggerKey>> getTriggerListenerMatchers( String listenerName);\r\n\r\n \r\n    public boolean removeTriggerListener(String name);\r\n\r\n \r\n    public List<TriggerListener> getTriggerListeners();\r\n \r\n    public TriggerListener getTriggerListener(String name);\r\n \r\n    public void addSchedulerListener(SchedulerListener schedulerListener);\r\n \r\n    public boolean removeSchedulerListener(SchedulerListener schedulerListener);\r\n\r\n \r\n    public List<SchedulerListener> getSchedulerListeners();\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n#### 4. 调度监听器\r\n\r\nSchedulerListeners非常类似于TriggerListeners和JobListeners，除了它们在Scheduler本身中接收到事件的通知 ，不一定与特定触发器（trigger）或job相关的事件。\r\n\r\n与计划程序相关的事件包括：添加job/触发器，删除job/触发器，调度程序中的严重错误，关闭调度程序的通知等。\r\n\r\n`org.quartz.SchedulerListener`接口\r\n\r\n```java\r\npublic interface SchedulerListener {  \r\n\r\n    public void jobScheduled(Trigger trigger);  \r\n\r\n    public void jobUnscheduled(String triggerName, String triggerGroup);  \r\n\r\n    public void triggerFinalized(Trigger trigger);  \r\n\r\n    public void triggersPaused(String triggerName, String triggerGroup);  \r\n\r\n    public void triggersResumed(String triggerName, String triggerGroup);  \r\n\r\n    public void jobsPaused(String jobName, String jobGroup);  \r\n\r\n    public void jobsResumed(String jobName, String jobGroup);  \r\n\r\n    public void schedulerError(String msg, SchedulerException cause);  \r\n\r\n    public void schedulerStarted();  \r\n\r\n    public void schedulerInStandbyMode();  \r\n\r\n    public void schedulerShutdown();  \r\n\r\n    public void schedulingDataCleared();  \r\n}  \r\n```\r\n\r\n调度监听器注册到调度器的监听管理器中，调度监听器实际上可以是实现org.quartz.SchedulerListener接口的任何对象。\r\n\r\n添加调度监听器\r\n\r\n```java\r\n//旧版\r\nscheduler.addSchedulerListener(new UpSchedulerListener()); //添加自定义调度器监听\r\n//新版 since 2.0\r\nscheduler.getListenerManager().addSchedulerListener(mySchedListener);\r\n```\r\n\r\n移除调度监听器\r\n\r\n```java\r\n//旧版\r\nscheduler.removeSchedulerListener(new UpSchedulerListener()); //移除自定义调度器监听\r\n//新版 since 2.0\r\nscheduler.getListenerManager().removeSchedulerListener(mySchedListener);\r\n```\r\n\r\n### 五、Job Stores\r\n\r\nJobStore负责跟踪您提供给调度程序的所有“工作数据”：jobs，triggers，日历等。 \r\n\r\n`JobStore`其实就是定时任务的相关数据存储。\r\n\r\n支持存储方式有：\r\n\r\n（1）RAMJobStore 内存定时数据存储。\r\n\r\n（2）JDBC JobStore 通过JDBC将其所有数据保存在数据库中。\r\n\r\n（3）TerracottaJobStore TerracottaJobStore用于在集群服务器内存储调度信息（Jobs，Triggers和calendars） \r\n\r\n#### RAMJobStore\r\n\r\nRAMJobStore是使用最简单的JobStore，配置简单，性能最高的（在CPU时间方面）。RAMJobStore以其明显的方式获取其名称，它将其所有数据保存在RAM中。缺点是当您的应用程序结束（或崩溃）时，所有调度信息都将丢失  - 这意味着RAMJobStore无法履行作业和triggers上的“非易失性”设置。\r\n\r\n使用RAMJobStore ，只需将类名称org.quartz.simpl.RAMJobStore指定为用于配置石英的JobStore类属性：\r\n\r\n配置Quartz以使用RAMJobStore\r\n\r\n```\r\norg.quartz.jobStore.class = org.quartz.simpl.RAMJobStore\r\n```\r\n\r\n其实在没有JDBC的情况下，默认就是RAMJobStore。\r\n\r\n#### JDBC JobStore\r\n\r\nJDBCJobStore几乎支持与任何数据库一起使用，已被广泛应用于Oracle，PostgreSQL，MySQL，MS SQLServer，HSQLDB和DB2。 \r\n\r\n数据库中各表的含义：\r\n\r\n|表名|表存储信息说明|\r\n|------|--------------------|\r\n|qrtz_blob_triggers　| 这张表示存储自己定义的trigger，不是quartz自己提供的trigger |\r\n|\tqrtz_calendars　　| 存储Calendar |\r\n|　　qrtz_cron_triggers　|  存储cronTrigger |\r\n|　　qrtz_fired_triggers　　| 存储触发的Tirgger |\r\n|　　qrtz_job_details　　| 存储JobDetail |\r\n|　　qrtz_locks　　　　| 存储程序中非悲观锁的信息 |\r\n|　　qrtz_paused_trigger_grps　　| 存储已暂停的Trigger组信息 |\r\n|　　qrtz_scheduler_state　　| 存储集群中note实例信息，quartz会定时读取该表的信息判断集群中 每个实例的当前状态 |\r\n|　　qrtz_simple_triggers　　| 存储simpleTrigger的信息|\r\n|　　qrtz_simprop_triggers　　| 储存CalendarIntervalTrigger和DailyTimeIntervalTrigger的信息|\r\n|　　qrtz_triggers　　| 存储已配置的trigger信息|\r\n\r\n### 六、其他\r\n\r\n后续再补充\r\n\r\n<br/>\r\n\r\n\r\n\r\n<br/>\r\n\r\n**相关文章**\r\n\r\n[定时任务之Java定时API](a516f8e8.html)\r\n[定时任务之Spring Task](5a5ab620.html)\r\n[定时任务之quartz](6ddb3c14.html)\r\n\r\n\r\n<br/>\r\n\r\n\r\n本文整理参考以下前辈链接，放个链接，以示感谢：\r\n\r\n - 参考文章1：https://blog.csdn.net/chengqiuming/java/article/details/84144534\r\n - 参考文章2：https://www.cnblogs.com/kyleinjava/p/10432168.html\r\n - 参考文章3：http://www.quartz-scheduler.org/documentation/quartz-2.3.0/\r\n - 参考文章4：https://www.w3cschool.cn/quartz_doc/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/pages/Back-end/Java/定时任务/TimeTask-quartz.md	(revision 640356315098df147a918066267421cc14c29e2c)
+++ docs/pages/Back-end/Java/定时任务/TimeTask-quartz.md	(date 1611388430534)
@@ -1,3 +1,4 @@
+<!-- 
 ---
 title: 定时任务之Quartz
 tags:
@@ -9,7 +10,9 @@
 abbrlink: 6ddb3c14
 date: 2020-07-18 23:00:00
 update: 2020-07-18 21:00:00
----
+--- -->
+
+## 定时任务之Quartz
 
 > 本文主要记录学习Quartz的相关内容。
   整理于2020-06-25，最后更新2020-07-18。
Index: docs/pages/Back-end/JUC/Juc-03-lilun.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n# 并发编程理论\r\n\r\n# 并发编程三大问题\r\n\r\n并发编程-多线程编程中需要解决的三个问题，或者说是三个基本原则。\r\n\r\n- 可见性。\r\n\r\n- 原子性。\r\n\r\n- 有序性。\r\n\r\n\r\n## 可见性\r\n\r\n可见性（Visibility）：是指一个线程对共享变量进行修改，其他线程可以立即得到修改后的新值。\r\n\r\n> 解决方案： Java 中 提供了`Volatile`关键字俩保证线程共享变量的可见性。\r\n\r\n验证示例：\r\n\r\n```java\r\npackage com.xiaocai.juc.threeproblem;\r\n\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n/**\r\n * @description: TODO 功能角色说明：\r\n * TODO 描述：\r\n * @author: 张小菜\r\n * @date: 2020/12/25 15:31\r\n * @version: v1.0\r\n */\r\npublic class VisibilityTest {\r\n\r\n    public static void main(String[] args) {\r\n        DataResource dataResource = new DataResource();\r\n\r\n        new Thread(() ->{\r\n            System.out.println(Thread.currentThread().getName() + \"\\t come in \");\r\n            try {\r\n                TimeUnit.SECONDS.sleep(3);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            //睡3秒之后再修改num,防止A线程先修改了num,那么到while循环的时候就会直接跳出去了\r\n            dataResource.dataAdd();\r\n            System.out.println(Thread.currentThread().getName() + \"\\t come out\");\r\n        },\"A\").start();\r\n\r\n\r\n        while(dataResource.num == 0){\r\n            //只有当num不等于0的时候,才会跳出循环\r\n        }\r\n    }\r\n}\r\nclass DataResource{\r\n    int num = 0;\r\n\r\n    public void dataAdd(){\r\n        this.num = 10;\r\n    }\r\n}\r\n```\r\n当没有加`Volatile`的时候,while循环永远不会退出。当`num`变量加了`Volatile`关键字， 一旦`num`被修改，其他线程就可以立即感知。\r\n\r\n由此可见 **关键字`Volatile`，可以保证线程的可见性。**\r\n\r\n注意事项\r\n>这里使用的是while循环，可以不停的去获取值，在实际实际开发中，使用`Volatile`修饰的变量，尽量避免使用`if`语句判断，因为`if`语句只会执行一次，并且有可能在变量值修改前执行或者在值修改后执行。\r\n\r\n\r\n## 原子性\r\n\r\n原子性（Atomicity）：在一次或多次操作中，要么所有的操作都成功执行并且不会受其他因素干扰而中 断，要么所有的操作都不执行或全部执行失败。不会出现中间状态，不会出现部分成功部分失败。\r\n\r\n> 解决方案\r\n（1）使用锁机制，使用`synchronized`关键字，或者使用Lock锁。\r\n（2）使用原子型的变量。 可以使用原子型的类，如`AtomicInteger`、`AtomicLong`。\r\n\r\n验证示例：\r\n\r\n```java\r\npackage com.xiaocai.juc.threeproblem;\r\n\r\n/**\r\n * @description: TODO 功能角色说明：\r\n * TODO 描述：\r\n * @author: 张小菜\r\n * @date: 2020/12/25 15:43\r\n * @version: v1.0\r\n */\r\npublic class AtomicityTest {\r\n\r\n    public static void main(String[] args) {\r\n        DataResource02 dataResource02 = new DataResource02();\r\n\r\n        for (int i = 0; i < 20; i++) {\r\n            new Thread(() ->{\r\n                for (int j = 0; j < 1000; j++) {\r\n                    dataResource02.increment();\r\n                }\r\n            },\"线程\" + String.valueOf(i)).start();\r\n        }\r\n\r\n        //需要等待上面的20个线程计算完之后再查看计算结果\r\n        while(Thread.activeCount() > 2){\r\n            Thread.yield();\r\n        }\r\n\r\n        System.out.println(\"20个线程执行完之后num:\\t\" + dataResource02.num);\r\n    }\r\n}\r\n\r\nclass DataResource02{\r\n    static int num = 0;\r\n\r\n    public void increment(){\r\n        this.num++;\r\n    }\r\n}\r\n```\r\n输出结果：\r\n\r\n```\r\n20个线程执行完之后num:\t19152\r\n```\r\n多运行几次之后，会发现每次结果不一样，因为现在是并发不安全的执行。如果保证每次操作都保证原子性，20个线程执行完，结果应该是20000。控制台输出的值却不是这个值，说明出现了原子性的问题，其实就是当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共 享变量，干扰了前一个线程的操作。\r\n\r\n\r\n使用`synchronized`关键字 修饰操作之后，可以得出正确的计算结果。\r\n\r\n\r\n\r\n\r\n\r\n \r\n## 有序性\r\n\r\n有序性（Ordering）：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行重排序优化操作来加快速度，会导致程序终的执行顺序不一定就是我们编写代码时的顺序。\r\n\r\n\r\n有序性不太好直接演示。好像可以通过 jcstress 压测工具进行演示。\r\n\r\n引入一个包\r\n\r\n```xml\r\n<dependency>   \r\n <groupId>org.openjdk.jcstress</groupId>    \r\n<artifactId>jcstress-core</artifactId>    \r\n<version>${jcstress.version}</version> \r\n</dependency>\r\n```\r\n关键的几个注解，借用一下代码：\r\n\r\n```java\r\n @JCStressTest\r\n // @Outcome: 如果输出结果是1或4，我们是接受的(ACCEPTABLE)，并打印ok\r\n @Outcome(id = {\"1\", \"4\"}, expect = Expect.ACCEPTABLE, desc = \"ok\")\r\n //如果输出结果是0，我们是接受的并且感兴趣的，并打印danger\r\n @Outcome(id = \"0\", expect = Expect.ACCEPTABLE_INTERESTING, desc = \"danger\")\r\n @State\r\n public class Test03Ordering {\r\n\r\n    int num = 0;\r\n    boolean ready = false;\r\n    // 线程1执行的代码\r\n    @Actor //@Actor：表示会有多个线程来执行这个方法\r\n    public void actor1(I_Result r) {\r\n        if (ready) {\r\n            r.r1 = num + num;\r\n        } else {\r\n            r.r1 = 1;\r\n        }\r\n    }\r\n\r\n    // 线程2执行的代码\r\n    // @Actor\r\n    public void actor2(I_Result r) {\r\n        num = 2;\r\n        ready = true;\r\n    }\r\n} \r\n```\r\n这里就不演示了。\r\n\r\n\r\n\r\n\r\n# Java 内存模型\r\n\r\n`Java Memory Molde` (Java内存模型/JMM)，注意不要将Java内存模型和Java内存结构（JVM划分的那个堆，栈，方法区）混淆。\r\n\r\n（1）Java 内存模型，是Java虚拟机规范中所定义的一种内存模型，是一套规范，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。\r\n\r\n（2）Java 内存模型主要围绕两个关键字，一个是`volatile`，一个是`synchronized`。\r\n\r\n## 关于Java内存模型的内容\r\n\r\nJava内存模型中，根据线程将内存分为主内存和工作内存。\r\n\r\nJava的线程不能直接在主内存中操作共享变量。而是首先将主内存中的共享变量赋值到自己的工作内存中，再进行操作，操作完成之后，刷回主内存。\r\n\r\n**主内存：**\r\n\r\n主内存是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。\r\n\r\n**工作内存：**\r\n\r\n每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的副本。线程对变量的所有的操 作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接 访问对方工作内存中的变量。\r\n\r\n![](../../../_media/juc/jmm-01.png)\r\n\r\n为什么要有JMM?\r\n\r\nJava内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。\r\n\r\n\r\n## 主内存与工作内存交互\r\n\r\n为了保证数据交互时数据的正确性，Java内存模型中定义了8种操作来完成这个交互过程，这8种操作本身都是原子性的。虚拟机实现时必须保证下面 提及的每一种操作都是原子的、不可再分的。 \r\n\r\n\r\n![](../../../_media/juc/jmm-02.png)\r\n\r\n- `lock`：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。\r\n\r\n- `unlock`：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。\r\n\r\n- `read`：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。\r\n\r\n- `load`：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。\r\n\r\n- `use`：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时都会执行这个操作。\r\n\r\n- `assign`：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\r\n\r\n- `store`：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write使用。\r\n\r\n- `write`：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。\r\n\r\n注意:\r\n\r\n（1）如果对一个变量执行`lock`操作，将会清空工作内存中此变量的值。 \r\n\r\n（2）对一个变量执行`unlock`操作之前，必须先把此变量同步到主内存中。 \r\n\r\n（3）`lock`和`unlock`操作只有加锁才会有。`synchronized`就是通过这样来保证可见性的。 \r\n \r\n\r\n\r\n## happens-before\r\n\r\n\r\nJMM 使用 happens-before 的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM 可以通过 happens-before 关系向程序员提供跨线程的内存可见性保证。\r\n\r\n**为什么要 happens-before ？**\r\n\r\nJVM 会对代码进行编译优化，会出现指令重排序情况，为了避免编译优化对并发编程安全性的影响，需要 happens-before 规则定义一些禁止编译优化的场景，保证并发编程的正确性。\r\n\r\n\r\n**基本含义：**\r\n\r\n（1）如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\r\n\r\n（2）两个操作之间存在 happens-before 关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。\r\n\r\n如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。\r\n\r\n**happens-before 规则**\r\n\r\n在Java中，有以下天然的 happens-before关系：\r\n\r\n- 1、程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\r\n\r\n- 2、锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作，比如说在代码里有先对一个lock.lock()，lock.unlock()，lock.lock()\r\n\r\n- 3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个volatile变量的读操作，volatile变量写，再是读，必须保证是先写，再读\r\n\r\n- 4、传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\r\n\r\n- 5、线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作，thread.start()，thread.interrupt()\r\n\r\n- 6、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\r\n\r\n- 7、线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\r\n\r\n- 8、对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\r\n \r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/pages/Back-end/JUC/Juc-03-lilun.md	(revision 640356315098df147a918066267421cc14c29e2c)
+++ docs/pages/Back-end/JUC/Juc-03-lilun.md	(date 1612755220409)
@@ -135,7 +135,7 @@
 
 
 
- 
+
 ## 有序性
 
 有序性（Ordering）：是指程序中代码的执行顺序，Java在编译时和运行时会对代码进行重排序优化操作来加快速度，会导致程序终的执行顺序不一定就是我们编写代码时的顺序。
@@ -247,19 +247,18 @@
 （2）对一个变量执行`unlock`操作之前，必须先把此变量同步到主内存中。 
 
 （3）`lock`和`unlock`操作只有加锁才会有。`synchronized`就是通过这样来保证可见性的。 
- 
+
 
 
 ## happens-before
 
 
-JMM 使用 happens-before 的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM 可以通过 happens-before 关系向程序员提供跨线程的内存可见性保证。
+JMM 使用 happens-before 的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM 可以通过 **happens-before** 关系向程序员提供跨线程的内存可见性保证。
 
 **为什么要 happens-before ？**
 
 JVM 会对代码进行编译优化，会出现指令重排序情况，为了避免编译优化对并发编程安全性的影响，需要 happens-before 规则定义一些禁止编译优化的场景，保证并发编程的正确性。
 
-
 **基本含义：**
 
 （1）如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
@@ -287,5 +286,12 @@
 - 7、线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
 
 - 8、对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
- 
+
 
+
+
+
+
+
+
+ 
\ No newline at end of file
Index: docs/pages/Back-end/Java/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Java 相关目录\r\n\r\n> 这是Java相关目录\r\n\r\n\r\n\r\n\r\n## 定时任务\r\n\r\n\r\n- Timer\r\n- Spring Task\r\n- Quartz\r\n\r\n## Linux 定时 crontab\r\n\r\n```bash\r\n# 检查安装\r\nrpm -qa | grep crontab\r\n\r\n# 安装\r\nyum install -y crontabs\r\n\r\n# 启动\r\nsystemctl start crond\r\n\r\n# 查看状态\r\nsystemctl status crond\r\n\r\n# 停止定时服务\r\nsystemctl stop crond\r\n\r\n# 开机启动\r\nsystemctl enable crond\r\n```\r\n\r\n\r\n定时任务参数说明：\r\n\r\n\r\n```bash\r\ncat /etc/crontab\r\n# .---------------- 分钟，取值范围为 0-59\r\n# |  .------------- 小时，取值范围为 0-23\r\n# |  |  .---------- 日，取值范围为 1-31\r\n# |  |  |  .------- 月，取值范围为 1-12\r\n# |  |  |  |  .---- 星期，取值范围为 0-7，0 和 7 都表示星期日\r\n# |  |  |  |  |      .-- 要执行的命令\r\n# |  |  |  |  |      |\r\n  0  19 *  *  *  username bash /home/test.sh\r\n```\r\n\r\n查询定时\r\n\r\n```bash\r\ncrontab -l\r\n```\r\n\r\n设置定时\r\n\r\n```bash\r\ncrontab -e\r\n```\r\n会自动打开一个空文件，可以设置任务。
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/pages/Back-end/Java/README.md	(revision 640356315098df147a918066267421cc14c29e2c)
+++ docs/pages/Back-end/Java/README.md	(date 1611389176497)
@@ -4,61 +4,13 @@
 
 
 
-
-## 定时任务
+## 定时任务 <!-- {docsify-ignore} -->
 
 
 - Timer
 - Spring Task
 - Quartz
-
-## Linux 定时 crontab
-
-```bash
-# 检查安装
-rpm -qa | grep crontab
-
-# 安装
-yum install -y crontabs
+- Linux + Crontab
 
-# 启动
-systemctl start crond
 
-# 查看状态
-systemctl status crond
-
-# 停止定时服务
-systemctl stop crond
-
-# 开机启动
-systemctl enable crond
-```
-
-
-定时任务参数说明：
-
-
-```bash
-cat /etc/crontab
-# .---------------- 分钟，取值范围为 0-59
-# |  .------------- 小时，取值范围为 0-23
-# |  |  .---------- 日，取值范围为 1-31
-# |  |  |  .------- 月，取值范围为 1-12
-# |  |  |  |  .---- 星期，取值范围为 0-7，0 和 7 都表示星期日
-# |  |  |  |  |      .-- 要执行的命令
-# |  |  |  |  |      |
-  0  19 *  *  *  username bash /home/test.sh
-```
-
-查询定时
-
-```bash
-crontab -l
-```
-
-设置定时
-
-```bash
-crontab -e
-```
-会自动打开一个空文件，可以设置任务。
\ No newline at end of file
+## IO 相关 <!-- {docsify-ignore} -->
\ No newline at end of file
Index: docs/pages/Back-end/Spring/Spring-002-Aop.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n## Spring 归纳 \r\n\r\n> 官网：https://spring.io/ <br/>\r\n文档直达：[Spring 文档](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware)\r\n\r\n一般，Spring 是 `Spring Framework` 的简称。\r\n\r\nSpring 是干嘛的？\r\n\r\n\r\n`Spring`可以让对象与对象（模块与模块）之间的关系不在通过硬编码关联，而是通过配置类或注解标记进行管理。\r\n`Spring`是一个容器。\r\n\r\n\r\n\r\n## 2.Spring AOP\r\n\r\n\r\nAOP全称：Aspect-Oriented Programming，面向切面编程。\r\n\r\nAOP 也是Spring 非常实用的核心组件。\r\n\r\nAOP可以为某一类对象进行控制，实现方法增加，在调用该类对象的具体方法的前后去调用其他需要使用模块，从而达到对原有对象功能扩充目的。\r\n\r\nSpring AOP是基于代理的框架，支持2种代理模式：\r\n - 使用JDK动态代理。JDK动态代理内置于JDK中。\r\n\r\n - CGLIB为给定的目标对象创建代理的动态代理。CGLIB是一个通用的开源类定义库，打包在`spring-core`包中。\r\n\r\n如果要代理的目标对象至少实现了一个接口，则使用JDK动态代理。目标类型实现的所有接口都是代理的。如果目标对象没有实现任何接口，则会创建一个CGLIB代理。\r\n\r\n强制使用CGLIB注意事项：\r\n（1）对于CGLIB，final方法不能被通知，因为它们不能在运行时生成的子类中被重写\r\n（2）Spring 4.0 之后，代理对象的构造函数不再被调用两次，因为CGLIB代理实例是通过objensis创建的。只有用户的JVM不允许构造函数绕过时，才会看到来自Spring的AOP支持的双重调用和相应的调试日志条目。\r\n\r\n开启强制cglib：\r\n\r\n```xml\r\n<aop:config proxy-target-class=\"true\">\r\n    <!-- other beans defined here... -->\r\n</aop:config>\r\n```\r\n>`proxy-target-class=\"true\"`可以用在`<tx:annotation-driven/>`，`<aop:aspectj-autoproxy/>`, `<aop:config/>`三个标签上开启强制CGLIB动态代理。\r\n\r\n如果使用@AspectJ自动代理支持：\r\n```xml\r\n<aop:aspectj-autoproxy proxy-target-class=\"true\"/>\r\n```\r\n\r\n### AOP启用与声明\r\n\r\n1. **AOP @Aspectj的启用**\r\n\r\n```xml\r\n<aop:aspectj-autoproxy/>\r\n```\r\n或者：\r\n\r\n```java\r\n@Configuration\r\n@EnableAspectJAutoProxy\r\npublic class AppConfig {\r\n\r\n}\r\n```\r\n\r\n2. **AOP切面声明**\r\n\r\n\r\nAOP切面声明方式有两种：`XML方式` 和 `注解方式`。\r\n\r\n- XML方式：\r\n```xml\r\n<bean id=\"myLogAspect\" class=\"com.xiaocai.MyLogAspect\">\r\n    <!-- configure properties of the aspect here -->\r\n</bean>\r\n```\r\n\r\n- 注解声明:\r\n\r\n```java\r\n@Aspect\r\npublic class MyLogAspect {\r\n\r\n}\r\n```    \r\n\r\n\r\n### 切入点支持\r\n\r\n**切入点声明表达式支持：**\r\n\r\n- `execution` ：用于匹配方法执行连接点。指定的连接点范围包或类。\r\n- `within`：使用`within(类型表达式)`。匹配指定类型内的方法执行；\r\n- `this`：常用于绑定形式。使用`this(类型全限定名)`匹配当前AOP代理对象类型的执行方法，注意是AOP代理对象的类型匹配，这样就可能包括引入接口方法也可以匹配；注意this中使用的表达式必须是类型全限定名，不支持通配符；\r\n- `target`：使用`target(类型全限定名)`。匹配当前目标对象类型的执行方法；注意是目标对象的类型匹配，这样就不包括引入接口也类型匹配；注意target中使用的表达式必须是类型全限定名，不支持通配符；\r\n- `args`：使用`args(参数类型列表)`。匹配当前执行的方法传入的参数为指定类型的执行方法；注意是匹配传入的参数类型，不是匹配方法签名的参数类型；参数类型列表中的参数必须是类型全限定名，通配符不支持。\r\n\r\n- `@target`：使用`@target(全限定类型名称的注解)`。匹配当前目标对象类型的执行方法，其中目标对象持有指定的注解。注解类型也必须是全限定类型名；\r\n- `@args`：使用`@args(全限定类型名称的注解)`。匹配当前执行的方法传入的参数持有指定注解的执行；注解类型也必须是全限定类型名；\r\n- `@within`：使用`@within(全限定类型名称的注解)`。匹配所有持有指定注解类型内的方法；注解类型也必须是全限定类型名。\r\n- `@annotation`：使用`@annotation(全限定类型名称的注解)`。匹配当前执行方法持有指定注解的方法；注解类型也必须是全限定类型名。\r\n\r\n- `bean`：匹配特定命名的bean或者带通配符的一组bean。 Spring aop环境特有的。\r\n\r\n\r\n**类型匹配语法符号：**\r\n\r\n - `*` ：匹配任何数量字符；\r\n - `..`：匹配任何数量字符的重复，如在类型模式中匹配任意数量子包，在方法参数模式中匹配任意数量参数。\r\n - `+` ：匹配指定类型的子类型；仅能作为后缀放在类型模式后边。\r\n\r\n\r\n**找点栗子说明：**\r\n\r\n- **bean 的示例**\r\n\r\n先看`bean`，比如将指定的bean作为切入点，参数可以是bean的id或者名字。\r\n\r\n```java\r\n    @Pointcut(\"bean(userService)\")\r\n    public void beanPoint(){\r\n\r\n    };\r\n```\r\nbean还支持通配符（`*`）和逻辑符 `&&`, ` || `，` ! `。\r\n\r\n如匹配所有的Service切入：\r\n```java\r\n    @Pointcut(\"bean(*Service)\")\r\n    public void beanPoint(){\r\n\r\n    };\r\n```\r\n如匹配所有非Dao切入：\r\n```java\r\n    @Pointcut(\"bean(!loginDao)\")\r\n    public void beanNotLoginDaoPoint(){\r\n\r\n    }\r\n```\r\n\r\n- `execution` 示例\r\n\r\n    - 匹配service 包下的任意无参的方法切入：\r\n```java\r\n@Pointcut(\"execution(* cn.xiaocai.*.service+.*())\")\r\nprivate void anyNoParamMethodUnderPackage() {} \r\n```\r\n    - 匹配 service 包下的任意只有一个参数的方法执行切入：\r\n```java\r\n@Pointcut(\"execution(* cn.xiaocai.*.service.*(*))\")\r\nprivate void anyOneParamMethodUnderPackage() {} \r\n```\r\n    - 匹配 service 包下的不限定参数的任意方法执行切入：\r\n```java\r\n@Pointcut(\"execution(* cn.xiaocai.*.service.*(..))\")\r\nprivate void anyMethodUnderPackage() {} \r\n```\r\n    - 匹配 service 包下的限定只有一个参数且参数类型为`java.util.Date`的方法执行切入：\r\n```java\r\n@Pointcut(\"execution(* cn.xiaocai.*.service.*(java.util.Date))\")\r\nprivate void givenParamaterType() {} \r\n```\r\n    - 匹配 service 包下的不限定参数的任意方法且抛出`IllegalArgumentException`和`ArrayIndexOutOfBoundsException`异常执行切入：\r\n```java\r\n@Pointcut(\"execution(* cn.xiaocai.*.service.*(..)) throws IllegalArgumentException, ArrayIndexOutOfBoundsException\")\r\nprivate void anyPackageWithException() {} \r\n```\r\n    - 匹配 任意路径下只有一个参数且参数声明（持有）`@Param`注解的任意方法执行切入：\r\n```java\r\n@Pointcut(\"execution(* *(@Param *)\")\r\nprivate void oneParamAnnotation() {} \r\n```\r\n    - 匹配所有被`@MyLog`注解修饰的任意方法：\r\n```java\r\n@Pointcut(\"@cn.xiaocai.annotation.MyLog * *(..)\")\r\nprivate void myLogAnnotation() {} \r\n```        \r\n    - 匹配任何被`@MyLog`和 `RequestMapping`注解修饰的方法：\r\n```java\r\n@Pointcut(\"@cn.xiaocai.annotation.MyLog @org.springframework.web.bind.annotation.RequestMapping  * *(..)\")\r\nprivate void manyAnnotation() {} \r\n```\r\n    - 匹配任何被`@BizEmail`或`BizWarn`注解修饰的方法：\r\n```java\r\n@Pointcut(\"@(cn.xiaocai.annotation.BizEmail || cn.xiaocai.annotation.BizWarn) * *(..)\")\r\nprivate void manyAnnotation() {} \r\n```\r\n    - 匹配 任意路径下参数声明`@MyAnnotation`注解并且参数类型上也有`@MyAnnotation`注解的任意方法：\r\n```java\r\n@Pointcut(\"* *(@MyAnnotation (@cn.xiaocai.annotation.MyAnnotation *), @cn.xiaocai.annotation.MyAnnotation (@cn.javass..MyAnnotation *))\")\r\nprivate void manyParamsAnnotation() {} \r\n```\r\n\r\n    - 任意公共方法执行切入：\r\n```java\r\n@Pointcut(\"execution(public * *(..))\")\r\nprivate void anyPublicOperation() {} \r\n```\r\n\r\n    - 任意update开头的方法切入：\r\n```java\r\n@Pointcut(\"execution(* update*(..))\")\r\nprivate void anyUpdateMethodOperation() {} \r\n```\r\n\r\n    - AccountService接口的任意方法切入:\r\n```java\r\n@Pointcut(\"execution(* com.xyz.service.AccountService.*(..))\")\r\nprivate void givenInterfaceOperation() {} \r\n```\r\n\r\n    - `com.xyz.service`包及子包下的任意方法切入:\r\n```java\r\n@Pointcut(\"execution(* com.xyz.service.*.*(..))\")\r\nprivate void givenPackageOperation() {} \r\n```\r\n    - `execution` 组合引用匹配的示例：\r\n```java\r\n@Aspect\r\npublic class CombinePointcuts{\r\n\r\n\t// 匹配任意public方法作为切入点\r\n\t@Pointcut(\"execution(public * *(..))\")\r\n\tprivate void anyPublicOperation() {} \r\n\r\n\t//匹配com.xyz.myapp.trading 包下的方法执行作为切入点。方法执行在交易模块中，则匹配切入\r\n\t@Pointcut(\"within(com.xyz.myapp.trading..*)\")\r\n\tprivate void inTrading() {\r\n\t\t\r\n\t} \r\n\r\n\t// 组合引用以上两者使用，匹配交易模块中的任意public方法\r\n\t@Pointcut(\"anyPublicOperation() && inTrading()\")\r\n\tprivate void tradingOperation() {}\r\n}\r\n```\r\n> 最好的做法是使用较小的命名组件构建更复杂的切入点表达式。\r\n\r\n\r\n- `within` 示例\r\n    - 指定包下的类任意连接点：\r\n```java\r\n@Pointcut(\"within(com.xyz.service.*)\")\r\nprivate void givenService() {}\r\n```\r\n    - 匹配指定包及子包下的BizPointcutService类型及子类型的任意方法：\r\n```java\r\n@Pointcut(\"within(com.xyz.service.BizPointcutService+)\")\r\nprivate void givenServiceAndSub() {}\r\n```\r\n    - 匹配目标对象的声明类型持有`@TTransactional`注解：\r\n```java\r\n@Pointcut(\"@within(org.springframework.transaction.annotation.Transactional)\")\r\nprivate void anyTargethasAnnotation() {}  \r\n```\r\n\r\n\r\n- `this` 示例\r\n    - Aop代理实现AccountService接口的任何连接点\r\n```java\r\n@Pointcut(\"this(com.xyz.service.AccountService)\")\r\nprivate void givenServiceProxyPoint() {}\r\n```    \r\n    - 声明注解的代理连接\r\n```java\r\n@Aspect\r\npublic class UsageTracking {\r\n\r\n    @DeclareParents(value=\"com.xzy.myapp.service.*+\", defaultImpl=DefaultUsageTracked.class)\r\n    public static UsageTracked mixin;\r\n\r\n    @Before(\"com.xyz.myapp.CommonPointcuts.businessService() && this(usageTracked)\")\r\n    public void recordUsage(UsageTracked usageTracked) {\r\n        usageTracked.incrementUseCount();\r\n    }\r\n}\r\n```    \r\n>这里使用`@DeclareParents`引入`UsageTracked`接口声明，就是引入接口使用接口的方法。而所有的Bean都实现了这个`UsageTracked`接口。每次调用公共切入的`businessService()` 方法时会自动找到对应的bean。  \r\n\r\n\r\n- `target` 示例\r\n\r\n所有实现了AccountService接口的实现类的目标对象切入连接点(针对接口)：\r\n\r\n```java\r\n@Pointcut(\"target(com.xyz.service.AccountService)\")\r\nprivate void anyTargetInterfaceImpl() {}  \r\n```\r\n特定实现类的目标对象切入连接点(针对具体的类)：\r\n\r\n```java\r\n@Pointcut(\"target(com.xyz.service.impl.AccountServiceImpl)\")\r\nprivate void anyTargetImplClass() {}  \r\n```\r\n\r\n- `args` 示例\r\n\r\n>`args` 匹配当前执行的方法传入的参数为指定类型的执行方法；注意是匹配传入的参数类型，不是匹配方法签名的参数类型；参数类型列表中的参数必须是类型全限定名，通配符不支持；args属于动态切入点，这种切入点开销非常大，非特殊情况最好不要使用；。\r\n\r\n匹配只有一个参数且参数类型为 `java.io.Serializable`方法切入：\r\n\r\n```java\r\n@Pointcut(\"args(java.io.Serializable)\")\r\nprivate void oneParamsForSerialized() {}  \r\n```\r\n\r\n匹配第一个参数的类型为 `java.io.Serializable`，后面跟任意个数任意类型的参数的方法切入：\r\n\r\n```java\r\n@Pointcut(\"args(java.io.Serializable,..)\")\r\nprivate void anyParamsForMany() {}  \r\n```\r\n\r\n- `@target` 示例\r\n\r\n目标对象持有`@Transactional`注解的\r\n\r\n```java\r\n@Pointcut(\"@target(org.springframework.transaction.annotation.Transactional)\")\r\nprivate void anyTargethasAnnotation() {}  \r\n```\r\n\r\n- `@annotation` 示例 \r\n\r\n持有`@Transactional`注解的执行方法：\r\n\r\n```java\r\n@Pointcut(\"@annotation(org.springframework.transaction.annotation.Transactional)\")\r\nprivate void anyMethodHasAnnotation() {}  \r\n```\r\n\r\n - 共享公共切入点的示例：\r\n\r\n\r\n```java\r\npackage com.xyz.myapp;\r\n\r\nimport org.aspectj.lang.annotation.Aspect;\r\nimport org.aspectj.lang.annotation.Pointcut;\r\n\r\n@Aspect\r\npublic class CommonPointcuts {\r\n\r\n    /**\r\n     * 切入方法在 com.xyz.myapp.web 包及子包下的类定义的方法\r\n     */\r\n    @Pointcut(\"within(com.xyz.myapp.web..*)\")\r\n    public void inWebLayer() {}\r\n\r\n    /**\r\n     * 切入方法在 com.xyz.myapp.service 包及子包下的类定义的方法\r\n     */\r\n    @Pointcut(\"within(com.xyz.myapp.service..*)\")\r\n    public void inServiceLayer() {}\r\n\r\n    /**\r\n     * 切入点在 com.xyz.myapp.dao 包及子包下的类定义的方法\r\n     */\r\n    @Pointcut(\"within(com.xyz.myapp.dao..*)\")\r\n    public void inDataAccessLayer() {}\r\n\r\n    /**\r\n     * 切入方法在 业务执行方法 com.xyz.myapp..service 包及子包的实现类中,接口声明模式\r\n     * 相当于bean(*Service) \r\n     */\r\n    @Pointcut(\"execution(* com.xyz.myapp..service.*.*(..))\")\r\n    public void businessService() {}\r\n\r\n    /**\r\n     *\r\n    * 切入方法在 业务执行方法 com.xyz.myapp.dao 包及子包的实现类中，接口声明模式\r\n     */\r\n    @Pointcut(\"execution(* com.xyz.myapp.dao.*.*(..))\")\r\n    public void dataAccessOperation() {}\r\n\r\n}\r\n```\r\n\r\n### 切入通知\r\n\r\n**通知声明**\r\n\r\n通知与切入点表达式相关联，并在与切入点匹配的方法执行之前、之后或周围运行。切入点表达式可以是对命名切入点的简单引用，也可以是就地声明的切入点表达式。\r\n\r\n几种通知形式：\r\n\r\n- `@Before`：前置通知。\r\n- `@After`：后置通知、最终通知。\r\n- `@AfterReturning`：返回后通知。\r\n- `@AfterThrowing`：抛出异常通知。目标方法抛出异常时执行。\r\n- `@Around`：环绕通知。\r\n\r\n#### @Before\r\n\r\n前置通知\r\n\r\n- 引用已经命名的切入点：\r\n```java\r\n@Aspect\r\npublic class MyLogAspect {\r\n\r\n\t@Pointcut(\"@annotation(com.xiaocai.base.demo.annotation.MyLog)\")\r\n    public void logPoint(){};\r\n\r\n    @Before(value = \"logPoint()\")\r\n    public void logBefore(){\r\n         \r\n    }\r\n}\r\n```\r\n\r\n- 就地声明切入点:\r\n```java\r\n@Aspect\r\npublic class MyLogAspect {\r\n\r\n    @Before(value = \"@annotation(com.xiaocai.base.demo.annotation.MyLog)\")\r\n    public void logBefore(){\r\n    }\r\n}\r\n```\r\n其他同理。\r\n\r\n\r\n#### @After\r\n\r\n类似`try-catch-finally`结构里的`finally`块。\r\n\r\n```java\r\n@Aspect\r\npublic class MyLogAspect {\r\n\t@Pointcut(\"@annotation(com.xiaocai.base.demo.annotation.MyLog)\")\r\n    public void logPoint(){};\r\n\r\n    @After(value = \"logPoint()\")\r\n    public void logAfter(){\r\n        log.info(\"--log After \");\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### @AfterReturning 返回后通知\r\n\r\n`@AfterReturning`的返回参数绑定到通知参数上。\r\n\r\n```java\r\nimport org.aspectj.lang.annotation.Aspect;\r\nimport org.aspectj.lang.annotation.AfterReturning;\r\n\r\n@Aspect\r\npublic class MyLogAspect {\r\n\r\n    @AfterReturning(\r\n        pointcut=\"com.xyz.myapp.CommonPointcuts.dataAccessOperation()\",\r\n        returning=\"retVal\")\r\n    public void doAccessCheck(Object retVal) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n> 该通知只能从连接点（用户声明的目标方法）本身接收异常。\r\n\r\n\r\n\r\n#### @Around 环绕通知\r\n\r\n- 基本示例\r\n\r\n```java\r\n@Aspect\r\npublic class MyLogAspect {\r\n\r\n\t@Pointcut(\"@annotation(com.xiaocai.base.demo.annotation.MyLog)\")\r\n    public void logPoint(){};\r\n\r\n\t@Around(value = \"logPoint()\")\r\n    public Object logAround(ProceedingJoinPoint joinPoint){\r\n        log.info(\"--log  Around  Before --\");\r\n        // 获取方法名称\r\n        String methodName = joinPoint.getSignature().getName();\r\n        // 获取入参\r\n        Object[] param = joinPoint.getArgs();\r\n        log.info(\"--methodName {},  param {}\", methodName, param);\r\n        // 继续执行方法\r\n        Object retVal = \r\n        try {\r\n            retVal = joinPoint.proceed();\r\n\r\n        } catch (Throwable throwable) {\r\n            throwable.printStackTrace();\r\n        }\r\n        log.info(\"--log  Around  After --\");\r\n        return retVal ;\r\n    }\r\n}\r\n```  \r\n>环绕通知的第一个参数必须是`ProceedingJoinPoint`类型。返回类型可以声明为`void`，`proceed()`方法最多只能调用一次，可以不调用。\r\n\r\n- 访问当前连接点\r\n比较实用的方法：\r\n  - getArgs（）：返回方法参数。\r\n  - getThis（）：返回代理对象。\r\n  - getTarget（）：返回目标对象。\r\n  - getSignature（）：返回所建议的方法的说明。\r\n  - toString（）：打印建议的方法的有用描述。\r\n\r\n`JoinPoint`接口源码：\r\n\r\n```java\r\npackage org.aspectj.lang;  \r\nimport org.aspectj.lang.reflect.SourceLocation;  \r\npublic interface JoinPoint {  \r\n    String toString();         //连接点所在位置的相关信息  \r\n    String toShortString();     //返回连接点的缩写字符串表示形式。\r\n    String toLongString();     //返回连接点的扩展字符串表示形式\r\n    Object getThis();         //返回AOP代理对象 ，返回当前正在执行的对象。\r\n    Object getTarget();       //返回目标对象  \r\n    Object[] getArgs();       //返回被通知方法参数列表  \r\n    Signature getSignature();  //返回当前连接点签名  \r\n    SourceLocation getSourceLocation();//返回连接点方法所在类文件中的位置  \r\n    String getKind();        //连接点类型  \r\n    StaticPart getStaticPart(); //返回一个封装此连接点的静态部分的对象\r\n} \r\n```    \r\n\r\n#### 通知参数传递\r\n\r\n使用`args`表达式进行参数绑定。\r\n\r\n```java\r\n@Before(\"com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)\")\r\npublic void validateAccount(Account account) {\r\n    // ...\r\n}\r\n```\r\n或者：\r\n```java\r\n@Pointcut(\"com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)\")\r\nprivate void accountDataAccessOperation(Account account) {}\r\n\r\n@Before(\"accountDataAccessOperation(account)\")\r\npublic void validateAccount(Account account) {\r\n    // ...\r\n}\r\n```\r\n> `args(account,..)` 的作用有两个：一是只匹配那些方法至少接受一个参数的方法执行；二是通过Account参数使通知可以使用实际的Account对象。\r\n\r\n代理对象（this）、目标对象（target）和注释（@within、@target、@annotation和@args）都可以以类似的方式绑定。\r\n\r\n比如我们自己定义一个注解，然后传递注解:\r\n\r\n我的注解：\r\n\r\n```java\r\n/**\r\n * @author Xiaocai.Zhang\r\n */\r\n@Documented\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Target({ElementType.METHOD})\r\npublic @interface LimitChecked {\r\n\tString name() default \"\";\r\n}\r\n```\r\n\r\n切面与通知：\r\n\r\n```java\r\n/**\r\n * @author Xiaocai.Zhang\r\n */\r\n@Slf4j\r\n@Aspect\r\n@Component\r\npublic class LimitCheckedAspect {\r\n\t@Pointcut(\"@annotation(com.xiaocai.base.demo.annotation.LimitChecked)\")\r\n    public void checkedPoint(){};\r\n\r\n    @Before(value = \"checkedPoint() && @annotation(limitChecked)\")\r\n    public void checkBefore(LimitChecked limitChecked){\r\n        String nameKey = limitChecked.name();\r\n    }\r\n\r\n    @Around(value = \"checkedPoint() && @annotation(limitChecked)\")\r\n    public CommonResult checkAround(ProceedingJoinPoint joinPoint, LimitChecked limitChecked){\r\n    \tString nameKey = limitChecked.name();\r\n    }\r\n}\r\n```\r\n这样在前置通知或环绕通知都可以拿到对应注解的属性值。\r\n\r\n#### 通知参数与泛型\r\n\r\nSpring Aop 可以处理类声明和方法参数中使用的泛型。\r\n\r\n声明接口:\r\n\r\n```java\r\npublic interface Sample<T> {\r\n    void sampleGenericMethod(T param);\r\n    void sampleGenericCollectionMethod(Collection<T> param);\r\n}\r\n```\r\n通知使用：\r\n\r\n```java\r\n@Before(\"execution(* ..Sample+.sampleGenericMethod(*)) && args(param)\")\r\npublic void beforeSampleMethod(MyType param) {\r\n    // Advice implementation\r\n}\r\n```\r\n#### 通知参数命名\r\n\r\n> 如果用户已明确指定参数名，则使用指定的参数名。通知和`@Pointcut`注解都有一个可选的`argNames`属性，可以使用它来指定带注释方法的参数名。\r\n\r\n```java\r\n@Before(value=\"com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)\",\r\n        argNames=\"bean,auditable\")\r\npublic void audit(Object bean, Auditable auditable) {\r\n    AuditCode code = auditable.value();\r\n    // ... use code and bean\r\n}\r\n```\r\n\r\n>如果第一个参数是JoinPoint、ProceedingJoinPoint或JoinPoint.StaticPart类型，则可以从`argNames`属性的值中省略参数的名称。\r\n\r\n```java\r\n@Before(value=\"com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)\",\r\n        argNames=\"bean,auditable\")\r\npublic void audit(JoinPoint jp, Object bean, Auditable auditable) {\r\n    AuditCode code = auditable.value();\r\n    // ... use code, bean, and jp\r\n}\r\n```\r\n\r\n不需要收集连接点上下文的，可以省略`argNames`属性。\r\n\r\n```java\r\n@Before(\"com.xyz.lib.Pointcuts.anyPublicMethod()\")\r\npublic void audit(JoinPoint jp) {\r\n    // ... use jp\r\n}\r\n```\r\n\r\n#### 多个切点或切面执行先后\r\n\r\n（1）实现 `org.springframework.core.Ordered` 接口\r\n（2）使用`@Order`注解。\r\n（3）数字越小，优先级越高。\r\n\r\n\r\n在切入点添加注解：\r\n\r\n```java\r\n    @Order(1) // Order 代表优先级，数字越小优先级越高\r\n    @Pointcut(\"@annotation(com.xiaocai.base.demo.annotation.LimitChecked)\")\r\n    public void checkedPoint(){};\r\n```\r\n在通知添加注解：\r\n\r\n一般是针对同一个切入点出现多个切面或多个通知操作时。\r\n\r\n```java\r\n\t@Order(1) \r\n    @Before(value = \"logPoint()\")\r\n    public void logBefore(){\r\n        log.info(\"--log before \");\r\n\r\n    }\r\n```\r\n\r\n\r\n## 切面实例化模型\r\n\r\n默认情况下，应用程序上下文中每个切面都有一个实例。AspectJ称之为单例实例化模型。\r\nSpring 支持 AspectJ的 `perthis` 和 `pertarget` 的实例化。\r\n\r\n```java\r\n@Aspect(\"perthis(com.xyz.myapp.CommonPointcuts.businessService())\")\r\npublic class MyAspect {\r\n\r\n    private int someState;\r\n\r\n    @Before(\"com.xyz.myapp.CommonPointcuts.businessService()\")\r\n    public void recordServiceUsage() {\r\n        // ...\r\n    }\r\n}\r\n```\r\n`perthis`子句的作用是为执行`businessService()`的每个唯一服务对象创建一个切面实例。每个唯一的对象会在与切入点表达式匹配的连接点处绑定到该对象。\r\n\r\n切面实例是在服务对象第一次调用方法时创建的，当服务对象不在生命周期范围内时，切面也无法进入声明周期范围。所以在创建切面实例之前，其中的任何通知都不会执行，但是只要创建了切面实例，其中声明的通知就可以在匹配的连接点上执行，当然前提是服务对象与之相关联了。\r\n\r\n`pertarget`实例化模型的工作方式与`perthis`完全相同，但它在匹配的连接点为每个唯一的目标对象创建一个方面实例。\r\n\r\n> 总结：perthis 和 pertarget 都可以进行切面实例化，但是`perthis`是单例模式的实例化，而`pertarget`是原型模式的实例化。\r\n\r\n\r\n## AOP Demo\r\n\r\n业务执行有时会由于并发问题而失败（例如，死锁失败者）。\r\n\r\n如果重试该操作，则下次尝试可能会成功，对于这种适合重试的业务服务，可以定义一个切面去实现重试操作：\r\n\r\n\r\n```java\r\n@Aspect\r\npublic class ConcurrentOperationExecutor implements Ordered {\r\n\r\n    private static final int DEFAULT_MAX_RETRIES = 2;\r\n\r\n    private int maxRetries = DEFAULT_MAX_RETRIES;\r\n    private int order = 1;\r\n\r\n    public void setMaxRetries(int maxRetries) {\r\n        this.maxRetries = maxRetries;\r\n    }\r\n\r\n    public int getOrder() {\r\n        return this.order;\r\n    }\r\n\r\n    public void setOrder(int order) {\r\n        this.order = order;\r\n    }\r\n\r\n    @Around(\"com.xyz.myapp.CommonPointcuts.businessService()\")\r\n    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {\r\n        int numAttempts = 0;\r\n        PessimisticLockingFailureException lockFailureException;\r\n        do {\r\n            numAttempts++;\r\n            try {\r\n                return pjp.proceed();\r\n            }\r\n            catch(PessimisticLockingFailureException ex) {\r\n                lockFailureException = ex;\r\n            }\r\n        } while(numAttempts <= this.maxRetries);\r\n        throw lockFailureException;\r\n    }\r\n}\r\n```\r\n\r\n该切面实现了有序接口`Ordered`，以便可以将切面的优先级设置为高于事务通知，因为每次重试时都需要一个新的事务。`maxRetries`和`order`属性都由Spring配置。主要重试操作逻辑发生在`doconcurrentooperation()`方法中。请注意，这里将重试逻辑应用于每个`businessService()`方法。 如果由于悲观的`LockingFailureException`而失败，我们将重试，知道达到我们设置的重试次数。\r\n\r\n对应的配置：\r\n\r\n```xml\r\n<aop:aspectj-autoproxy/>\r\n\r\n<bean id=\"concurrentOperationExecutor\" class=\"com.xyz.myapp.service.impl.ConcurrentOperationExecutor\">\r\n    <property name=\"maxRetries\" value=\"3\"/>\r\n    <property name=\"order\" value=\"100\"/>\r\n</bean>\r\n```\r\n\r\n要优化切面使其只重试幂等操作，定义一个幂等注解\r\n\r\n```java\r\n@Retention(RetentionPolicy.RUNTIME)\r\npublic @interface Idempotent {\r\n    // marker annotation\r\n}\r\n```\r\n然后使用`@Idempotent`注解来注释服务操作的实现。\r\n\r\n优化匹配连接点：\r\n\r\n```java\r\n@Around(\"com.xyz.myapp.CommonPointcuts.businessService() && \" +\r\n        \"@annotation(com.xyz.myapp.service.Idempotent)\")\r\npublic Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {\r\n    // ...\r\n}\r\n```\r\n\r\n## XML AOP\r\n\r\nXML模式用的少，暂时就先不整理了。\r\n\r\n## Spring中使用AspectJ进行加载时织入\r\n\r\n加载时织入，LoadTimeWeaving，简称LTW。\r\n\r\nAOP通过为目标类织入切面的方式，实现对目标类功能的增强。按切面被织如到目标类中的时间划分，主要有3种:\r\n\r\n- 运行时织入\r\n这是最常见的，比如在运行期通过为目标类生成动态代理的方式实现AOP就属于运行期织入，这也是Spring AOP中的默认实现,Spring也提供了两种创建动态代理的方式：自带的JDK针对接口的动态代理和使用CGLib动态创建子类的方式创建动态代理。\r\n\r\n- 编译时织入\r\n使用特殊的编译器在编译期将切面织入目标类,这种比较少见,因为需要特殊的编译器的支持。\r\n\r\n- 加载时织入 \r\n\r\n类加载时织入通过字节码编辑技术在类加载期将切面织入目标类中，它的核心思想是在目标类的class文件被JVM加载前,通过自定义类加载器或者类文件转换器将横切逻辑织入到目标类的class文件中,然后将修改后class文件交给JVM加载。这种织入方式可以简称为LTW(LoadTimeWeaving)。\r\n\r\n\r\nSpring的LTW支持中的关键组件是`LoadTimeWeaver`接口（在`org.springframework.instrument.classloading`包）。`LoadTimeWeaver`接口源码：\r\n\r\n```java\r\npackage org.springframework.instrument.classloading;\r\n\r\nimport java.lang.instrument.ClassFileTransformer;\r\n\r\npublic interface LoadTimeWeaver {\r\n    void addTransformer(ClassFileTransformer var1);\r\n\r\n    ClassLoader getInstrumentableClassLoader();\r\n\r\n    ClassLoader getThrowawayClassLoader();\r\n}\r\n```\r\n\r\n基本原理：\r\n\r\n`Spring LTW`通过读取classpath下`META-INF/aop.xml`文件，获取切面类和要被切面织入的目标类的相关信息，再通过`LoadTimeWeaver`在`ClassLoader`加载类文件时将切面织入目标类中。\r\n\r\nSpring中可以通过`LoadTimeWeaver`将Spring提供的`ClassFileTransformer`注册到ClassLoader类加载器中。在类加载时，注册的`ClassFileTransformer`读取类路径下`META-INF/aop.xml`文件中定义的切面类和目标类信息，在目标类的class文件真正被VM加载前织入切面信息，生成新的Class文件字节码，然后交给VM加载，然后创建目标类的实例，实现AOP功能。\r\n\r\n\r\nspring支持需要2个包。\r\n\r\n- spring-aop.jar\r\n- aspectjweaver.jar\r\n- spring-instrument.jar（如果使用Spring提供的代理来启用检测）\r\n\r\n\r\n官方Demo\r\n\r\n1、首先声明切入点和切面\r\n\r\n```java\r\npackage foo;\r\n\r\nimport org.aspectj.lang.ProceedingJoinPoint;\r\nimport org.aspectj.lang.annotation.Aspect;\r\nimport org.aspectj.lang.annotation.Around;\r\nimport org.aspectj.lang.annotation.Pointcut;\r\nimport org.springframework.util.StopWatch;\r\nimport org.springframework.core.annotation.Order;\r\n\r\n@Aspect\r\npublic class ProfilingAspect {\r\n\r\n    @Around(\"methodsToBeProfiled()\")\r\n    public Object profile(ProceedingJoinPoint pjp) throws Throwable {\r\n        StopWatch sw = new StopWatch(getClass().getSimpleName());\r\n        try {\r\n            sw.start(pjp.getSignature().getName());\r\n            return pjp.proceed();\r\n        } finally {\r\n            sw.stop();\r\n            System.out.println(sw.prettyPrint());\r\n        }\r\n    }\r\n\r\n    @Pointcut(\"execution(public * foo..*.*(..))\")\r\n    public void methodsToBeProfiled(){}\r\n}\r\n```\r\n\r\n2、创建创一个`META-INF/aop.xml`文件\r\n\r\n创建创`META-INF/aop.xml`文件用于通知`AspectJ weaver`将我们的切面`ProfilingAspect`编织到类中。\r\n\r\n`aop.xml` 配置：\r\n\r\n```xml\r\n<!DOCTYPE aspectj PUBLIC \"-//AspectJ//DTD//EN\" \"https://www.eclipse.org/aspectj/dtd/aspectj.dtd\">\r\n<aspectj>\r\n    <weaver>\r\n        <!-- 要织入切面的目标类 这里使用的是包，也可以明确指定某个类 foo.StubEntitlementCalculationService  -->\r\n        <include within=\"foo.*\"/>\r\n    </weaver>\r\n\r\n    <aspects>\r\n        <!-- 要织入的切面 -->\r\n        <aspect name=\"foo.ProfilingAspect\"/>\r\n    </aspects>\r\n</aspectj>\r\n```\r\n3、开启LTW支持\r\n\r\nSpring 的XML配置开启LTW.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context\r\n        https://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n    <!-- 要织入的模板 service -->\r\n    <bean id=\"entitlementCalculationService\"\r\n            class=\"foo.StubEntitlementCalculationService\"/>\r\n\r\n    <!-- 开启LTW支持 -->\r\n    <context:load-time-weaver/>\r\n</beans>\r\n```\r\n\r\n如果是在 SpringBoot 中可以使用`@EnableLoadTimeWeaving`注解开启LTW支持。\r\n\r\n```java\r\n@Configuration\r\n@ComponentScan(\"com.xiaocai.ltw.*\")\r\n@EnableLoadTimeWeaving(aspectjWeaving=AUTODETECT)\r\npublic class LtwAopConfig{\r\n}\r\n```\r\n\r\n4、测试LTW\r\n\r\n```JAVA\r\npackage foo;\r\n\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic final class Main {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\", Main.class);\r\n\r\n        EntitlementCalculationService entitlementCalculationService =\r\n                (EntitlementCalculationService) ctx.getBean(\"entitlementCalculationService\");\r\n\r\n        // 验证切面织入\r\n        entitlementCalculationService.calculateEntitlement();\r\n    }\r\n}\r\n```\r\n5、使用代理开启\r\n\r\n可以直接使用java代理来执行main方法：\r\n\r\n```bash\r\njava -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main\r\n```\r\n\r\n或者配置JVM运行参数：\r\n```\r\n-javaagent:C:/projects/foo/lib/global/spring-instrument.jar\r\n```\r\n\r\n\r\n如果是 springboot 可以引入对应的jar包组件配置\r\n\r\n```xml\r\n\t\t<plugin>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-maven-plugin</artifactId>\r\n            <configuration>\r\n                <agent>\r\n                    ${settings.localRepository}/org/aspectj/aspectjweaver/${aspectj.version}/aspectjweaver-${aspectj.version}.jar\r\n                </agent>\r\n                <agent>\r\n                    ${settings.localRepository}/org/springframework/spring-instrument/${spring.version}/spring-instrument-${spring.version}.jar\r\n                </agent>\r\n            </configuration>\r\n        </plugin>\r\n```\r\n\r\n对于独立的java应用程序，spring提供了一个`InstrumentationLoadTimeWeaver`，需要一个通用的JVM代理`spring-instrument.jar`。由`@EnableLoadTimeWeaving`和 `<context:load-time-weaver/>`的配置完成自动检测。同时必须配置jvm参数：\r\n\r\n```\r\n-javaagent:/path/to/spring-instrument.jar\r\n```\r\n\r\n\r\n在上面的配置中，如果要指定特定的`LoadTimeWeaver`可以进行配置。\r\n\r\n- 使用Java配置：\r\n\r\n指定特定的`LoadTimeWeaver`需要实现`LoadTimeWeavingConfigurer`接口并重写`getLoadTimeWeaver()`方法\r\n\r\n```java\r\n@Configuration\r\n@EnableLoadTimeWeaving\r\npublic class AppConfig implements LoadTimeWeavingConfigurer {\r\n\r\n    @Override\r\n    public LoadTimeWeaver getLoadTimeWeaver() {\r\n        return new ReflectiveLoadTimeWeaver();\r\n    }\r\n}\r\n```\r\n- 使用XML配置：\r\n\r\n直接配置对应的`weaver-class`即可。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context\r\n        https://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n    <context:load-time-weaver\r\n            weaver-class=\"org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver\"/>\r\n\r\n</beans>\r\n```
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/pages/Back-end/Spring/Spring-002-Aop.md	(revision 640356315098df147a918066267421cc14c29e2c)
+++ docs/pages/Back-end/Spring/Spring-002-Aop.md	(date 1616661646593)
@@ -12,9 +12,35 @@
 `Spring`可以让对象与对象（模块与模块）之间的关系不在通过硬编码关联，而是通过配置类或注解标记进行管理。
 `Spring`是一个容器。
 
+## Spring AOP 主要应用场景
+
+Authentication 权限、
+
+Caching  缓存、
+
+Context passing 内容传递、
 
+Error handling 错误处理、
 
-## 2.Spring AOP
+Lazy loading 懒加载、
+
+Debugging  调试、
+
+logging, tracing, profiling and monitoring 记录跟踪优化校准、
+
+Performance  optimization 性能优化、
+
+Persistence 持久化、
+
+Resource pooling 资源池、
+
+Synchronization  同步、
+
+Transactions 事务。
+
+
+
+## Spring AOP
 
 
 AOP全称：Aspect-Oriented Programming，面向切面编程。
@@ -84,7 +110,7 @@
 public class MyLogAspect {
 
 }
-```    
+```
 
 
 ### 切入点支持
@@ -177,7 +203,7 @@
 ```java
 @Pointcut("@cn.xiaocai.annotation.MyLog * *(..)")
 private void myLogAnnotation() {} 
-```        
+```
     - 匹配任何被`@MyLog`和 `RequestMapping`注解修饰的方法：
 ```java
 @Pointcut("@cn.xiaocai.annotation.MyLog @org.springframework.web.bind.annotation.RequestMapping  * *(..)")
@@ -263,7 +289,7 @@
 ```java
 @Pointcut("this(com.xyz.service.AccountService)")
 private void givenServiceProxyPoint() {}
-```    
+```
     - 声明注解的代理连接
 ```java
 @Aspect
@@ -277,7 +303,7 @@
         usageTracked.incrementUseCount();
     }
 }
-```    
+```
 >这里使用`@DeclareParents`引入`UsageTracked`接口声明，就是引入接口使用接口的方法。而所有的Bean都实现了这个`UsageTracked`接口。每次调用公共切入的`businessService()` 方法时会自动找到对应的bean。  
 
 
@@ -498,7 +524,7 @@
         return retVal ;
     }
 }
-```  
+```
 >环绕通知的第一个参数必须是`ProceedingJoinPoint`类型。返回类型可以声明为`void`，`proceed()`方法最多只能调用一次，可以不调用。
 
 - 访问当前连接点
@@ -526,7 +552,7 @@
     String getKind();        //连接点类型  
     StaticPart getStaticPart(); //返回一个封装此连接点的静态部分的对象
 } 
-```    
+```
 
 #### 通知参数传递
 
Index: docs/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n# 前言   <!-- {docsify-ignore} -->\r\n\r\n\r\n　　已经有博客了，为什么还要搞个文档库？依赖是这种文档式结构在检索上比博客看上去更适合查资料，如果你博客内容比较多时，你不一定记得自己原来整理过什么，文档化就是为了更快捷的查询想要的内容。同时文档化就是典型的知识分区，知识树形化，也让自己加深印象。\r\n\r\n\r\n# 名字  <!-- {docsify-ignore} -->\r\n\r\n\r\n　　这是一个供我自己使用的个人知识库，仅仅为了把自己的学习的知识进行归纳整理，可以方便自己查阅使用的。\r\n\t\r\n\t没想好项目叫什么，暂时就叫它 <font color=\"red\"><b>Small-Docs</b></font> 。\r\n\r\n　　如果你也想做一个，参考 >> [docsify](https://docsify.js.org/#/zh-cn/)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/README.md	(revision 640356315098df147a918066267421cc14c29e2c)
+++ docs/README.md	(date 1656149955135)
@@ -8,8 +8,6 @@
 # 名字  <!-- {docsify-ignore} -->
 
 
-　　这是一个供我自己使用的个人知识库，仅仅为了把自己的学习的知识进行归纳整理，可以方便自己查阅使用的。
-	
-	没想好项目叫什么，暂时就叫它 <font color="red"><b>Small-Docs</b></font> 。
+　　这是一个供我自己使用的个人知识库，仅仅为了把自己的学习的知识进行归纳整理，可以方便自己查阅使用的。没想好项目叫什么，暂时就叫它 <font color="red"><b>Small-Docs</b></font> 。
 
 　　如果你也想做一个，参考 >> [docsify](https://docsify.js.org/#/zh-cn/)
\ No newline at end of file
Index: docs/pages/Back-end/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># 后端\r\n\r\n> 这是后端相关的文档\r\n\r\n\r\n## Java\r\n \r\n## JUC\r\n\r\n\r\n## Sping\r\n\r\n\r\n## SpringBoot\r\n\r\n\r\n## SpringCloud
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/pages/Back-end/README.md	(revision 640356315098df147a918066267421cc14c29e2c)
+++ docs/pages/Back-end/README.md	(date 1656150298781)
@@ -2,16 +2,14 @@
 
 > 这是后端相关的文档
 
+## 异常库
 
 ## Java
  
 ## JUC
 
-
 ## Sping
 
-
 ## SpringBoot
 
-
 ## SpringCloud
\ No newline at end of file
Index: docs/pages/Back-end/Java/定时任务/TimeTask-spring-task-1.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>---\r\ntitle: 定时任务之Spring Task\r\ntags:\r\n  - Spring Task\r\ncategories: 定时任务\r\nsummary: 本文整理Spring Task的不同场景不同用法。\r\nkeywords: 'java,sql,spring task定时任务,定时任务,cron表达式'\r\nauthor: Small-Rose / 张小菜\r\nabbrlink: 5a5ab620\r\ndate: 2020-07-18 22:00:00\r\nupdate: 2020-07-18 22:00:00\r\n---\r\n\r\n## 定时任务之Spring Task\r\n\r\n> 本文主要记录学习Spring Task的相关内容。\r\n  整理于2020-06-25，最后更新2020-07-18。\r\n\r\n##  一、简述\r\n\r\n> Spring 3.0以后推出的定时器类调度工具，Spring Task是一个轻量级的quartz。\r\n>\r\n> 配置简单，功能较为齐全，在实际项目中经常会用到。\r\n>\r\n> spring task在spring-context的模块中，无需单独引入。\r\n>\r\n> spring task支持xml配置、注解配置、java配置三种方式。本文分别演示3种不同的使用方式。\r\n\r\n关于调度的实现方式主要有三种：\r\n\r\n（1）Java自带的Api有个Timer类和TimerTask类。\r\n\r\n（2）Spring自带的Spring Task调度工具。\r\n\r\n（3）Quartz（读阔子）开源框架，功能强大，使用起来稍显复杂。\r\n\r\n本文主要记录第二种。其他两种请参考文章底部相关文章。\r\n\r\n在开始之前需要说明是一个定时任务的几个组件：\r\n\r\n（A）执行的任务类；\r\n\r\n（B）触发任务的触发器；\r\n\r\n（C）管理任务的任务调度器。\r\n\r\n后续配置都是以这三点为中心进行的。\r\n\r\n\r\n\r\n## 二 Spring Task 使用方式\r\n\r\n### 1、XML方法\r\n\r\nXML算是比较传统的方式，需要手工配置\r\n\r\n实例：\r\n\r\n执行的任务类：\r\n\r\n```java\r\npackage com.xiaocai.job;\r\nimport static java.lang.System.out;\r\npublic class UserTask {\r\n\r\n\tpublic void doSomething(){\r\n\t\tout.println(\" this is  user task \");\r\n\t}\r\n}\r\n```\r\n\r\nXML配置：\r\n\r\n```xml\r\n<bean id=\"userTask\" class=\"com.xiaocai.job.TaskTest\"/>\r\n<task:scheduled-tasks>\r\n        <task:scheduled ref=\"userTask\" method=\"doSomething\" cron=\"0/5 * * * * ?\" />\r\n</task:scheduled-tasks>\r\n```\r\n\r\ncron就是执行表达式：`0/5 * * * * ?`表示每5s执行一次。\r\n\r\n**参数说明：**\r\n\r\n`scheduled-tasks` ：调度任务池，可以定义多个任务task，这里指定了一个任务task。\r\n\r\n`scheduled`：可以理解为一个调度实例。其中：`ref`表示调度的执行任务类，`method`表示执行任务类中的调度的方法；`cron`调度执行时间频次表达式，一般顺序是，`秒 分 时 日 月 周 年`，年通常都会省略。具体的表达式规则，单独参考《定时任务Cron的使用》。\r\n\r\n`task`中用于指定时间频率的方式主要有：\r\n\r\n（1）`cron` 定时表达式模式。\r\n\r\n（2）fixed-rate：固定频次执行。单位毫秒，每隔指定时间执行一次\r\n\r\n（3）fixed-delay：固定延迟执行。单位毫秒，上次执行任务完成后，间隔指定时间后执行下次任务。\r\n\r\n（4）initial-delay：首次执行延迟。单位毫秒，第一次执行任务的时候，延迟指定时间再执行。\r\n\r\n> spring task 默认使用的是同步模式，即上次任务执行完后，才会执行下次任务。上述时间频率只有在非同步模式下才会完全符合，在同步模式下，实际计算方式为：\r\n>  **fixed-rate** ：任务的实际执行时间+fixedRate时间之后，执行下次任务\r\n>  **fixed-delay**：任务的实际执行时间如果小于fixedDelay，则时间间隔为fixedDelay；如果任务的实际执行时间大于fixedDelay，则上次任务执行完后，立即执行下一次任务。\r\n>\r\n>\r\n\r\n\r\n\r\n**适用场景**\r\n\r\n适合的定时任务，比较稳定、不经常变化，操作，日志要求不严格。\r\n\r\n\r\n\r\n### 2、注解配置\r\n\r\n执行任务类：\r\n\r\n```java\r\npackage com.xiaocai.job;\r\nimport static java.lang.System.out;\r\n\r\n@Component\r\npublic class UserTask {\r\n\r\n    @Scheduled(cron = \"0 0/5 * * * ?\")\r\n    @Async(\"executor\")\r\n\tpublic void doSomethingAnnotation(){\r\n\t\tout.println(\" this is  user task for Annotation \");\r\n\t}\r\n}\r\n```\r\n\r\n配置方式分有XML和无XML。\r\n\r\n（A）有XML的配置：\r\n\r\n```xml\r\n<!-- 定时任务配置 scheduler 注解方式  -->\r\n<task:executor id=\"executor\" pool-size=\"5\" /> \r\n<task:scheduler id=\"scheduler\" pool-size=\"10\" /> \r\n<task:annotation-driven executor=\"executor\" scheduler=\"scheduler\" /> <!-- 启用注解 -->\r\n<\r\n```\r\n\r\n参数说明：**\r\n\r\n`@Async`：spring异步模式支持，`@Async`的值为执行器`executor`，内部默认为名为`SimpleAsyncTaskExecutor`的线程池来执行任务。名字需要与xml中配置的一致。如果不要求异步，该注解可略。`@Async`使用之后，方法仍然是由一个线程来同步执行的。\r\n\r\n`executor`：用于配置线程池。`pool-size`：线程池数量，可设置范围，也可设置指定值，取值范围[ 1，`Integer.MAX_VALUE`]。\r\n\r\n`scheduler `：用于配置任务调度器。`pool-size`：调度池数量，可设置范围，也可设置指定值，取值范围[ 1，`Integer.MAX_VALUE`]。\r\n\r\n啰嗦一句，如果没有使用`@Component`或`@Service`注解，则y要配置一下执行任务栏的`bean`，多个执行任务类可以执行扫描包：\r\n\r\n```xml\r\n<context:component-scan base-package=\"com.xiaocai.job\" /> \r\n```\r\n\r\n（B）无XML配置：\r\n\r\n如`springboot`中使用，直接在启动类添加调度注解即可。`@EnableScheduling`是在Spring 3.1之后可以使用。\r\n\r\n如果需要开启并行执行，使用异步注解。在启动类上加入`@EnableAsync `。\r\n\r\n```java\r\npackage com.xiaocai.web;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.scheduling.annotation.EnableScheduling;\r\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\r\n\r\n@SpringBootApplication\r\n@EnableAsync\r\n@EnableScheduling\r\npublic class TimeTaskApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(TimeTaskApplication.class, args);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n示例：\r\n\r\n```java\r\npackage com.xiaocai.web.job;\r\n@Component\r\npublic class UserTask {\r\n    \r\n    //@Scheduled(cron = \"0 0/5 * * * ?\")\r\n    //@Scheduled(fixedDelayString=\"3000\")\r\n\t@Scheduled(fixedRate=2000)\r\n\tpublic void doUserHandle(){\r\n\t\tSystem.out.println(\" --- \"+LocalDateTime.now()+\"-- task for Annotation \");\r\n\t}\r\n}\r\n```\r\n\r\n执行结果：\r\n\r\n```txt\r\n --- 2020-06-25T16:08:18.455-- task for Annotation \r\n --- 2020-06-25T16:08:20.458-- task for Annotation\r\n --- 2020-06-25T16:08:22.460-- task for Annotation\r\n --- 2020-06-25T16:08:24.463-- task for Annotation\r\n --- 2020-06-25T16:08:26.455-- task for Annotation \r\n```\r\n\r\n注解中，除了`@Scheduled(fixedRate=2000)`和`@Scheduled(cron = \"0 0/5 * * * ?\")`还有`fixedRateString`、`fixedDelay`、`fixedDelayString`、`initialDelay`、`initialDelayString`等可以自行尝试。\r\n\r\n\r\n\r\n**适用场景**\r\n\r\n与XML使用类似，把XML变成了注解。可以配合spring异步注解，实现任务线程的并行。\r\n\r\n\r\n\r\n### 3、Java方式\r\n\r\n使用java方法可以实现`SchedulingConfigurer `接口的`configureTasks`方法。利用调度任务注册器`ScheduledTaskRegistrar`来注册需要执行的任务。添加任务的方式有：\r\n\r\n![添加任务方式](/images/time-task/spring-task.png)\r\n\r\n示例：\r\n\r\n业务执行类：\r\n\r\n```java\r\npackage com.xiaocai.job;\r\n\r\nimport java.time.LocalDateTime;\r\n\r\npublic class BuzTask implements Runnable {\r\n\t//当前业务执行参数\r\n\tprivate String jobData = \"\";\r\n\t\r\n\tpublic BuzTask() {}\r\n\tpublic BuzTask(String jobData) {\r\n\t\t this.jobData = jobData;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void run() {\r\n\t\ttry {\r\n            System.out.println(\" jobData : \" +jobData);\r\n\t\t   System.out.println(\" execute buzz code ...\" + LocalDateTime.now());\r\n\t\t}catch (Exception e) {\r\n\t\t}\r\n\t}\r\n\r\n\tpublic String getJobData() {\r\n\t\treturn jobData;\r\n\t}\r\n\tpublic void setJobData(String jobData) {\r\n\t\tthis.jobData = jobData;\r\n\t}\r\n\r\n}\r\n```\r\n\r\n自定义的调度管理类：\r\n\r\n```java\r\npackage com.xiaocai.job;\r\n\r\nimport java.util.Date;\r\n\r\nimport org.springframework.scheduling.Trigger;\r\nimport org.springframework.scheduling.TriggerContext;\r\nimport org.springframework.scheduling.annotation.SchedulingConfigurer;\r\nimport org.springframework.scheduling.config.ScheduledTaskRegistrar;\r\nimport org.springframework.scheduling.support.CronTrigger;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\npublic class SomeTaskUtil implements SchedulingConfigurer{\r\n \r\n\t//这些参数也可以使用单独的JavaBean,或保存在数据库\r\n    private  String cron =\"0/10 * * * * ?\";\r\n    private String taskName = \"Schedule_\";\r\n    private String jobData = \"\"; //公共执行参数\r\n\tprivate BuzTask buzTask;\r\n\t@Override\r\n\tpublic void configureTasks(ScheduledTaskRegistrar taskRegistrar) {\r\n\t\tbuzTask = new BuzTask(jobData);\r\n        //注册调度任务\r\n\t\ttaskRegistrar.addTriggerTask(buzTask, getTrigger());\r\n\t}\r\n\t\r\n\r\n   /**（也可以像任务执行类一样写在外面）\r\n    * 业务触发器\r\n    * @return\r\n    */\r\n   private Trigger getTrigger() {\r\n       return new Trigger() {\r\n           @Override\r\n           public Date nextExecutionTime(TriggerContext triggerContext) {\r\n               // 触发器\r\n               CronTrigger trigger = new CronTrigger(cron);\r\n               return trigger.nextExecutionTime(triggerContext);\r\n           }\r\n       };\r\n   }\r\n\t//getter setter   \r\n}\r\n```\r\n\r\nController类：\r\n\r\n```java\r\npackage com.xiaocai.job;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\n\r\n@Controller\r\npublic class TaskController {\r\n    \r\n    @Autowired\r\n    private SomeTaskUtil someTaskUtil ;\r\n    \r\n    @RequestMapping(\"/timeTask\")\r\n    public String timeTask(HttpServletRequest request){\r\n\t\t//这里跳测试页面，页面就三个文本框用来传，taskName ，cron，jobData\r\n        return \"timeTask\";\r\n    }\r\n\r\n    @RequestMapping(\"/timeTask/changeCron\")\r\n    public Map<String,Object> changeCron(String taskName,String cron,String jobData){\r\n        System.out.println(\" taskName \"+taskName);\r\n        System.out.println(\" cron \"+taskName);\r\n        System.out.println(\" jobData \" + taskName);\r\n        someTaskUtil.setTaskName(taskName);\r\n        someTaskUtil.setCron(cron);\r\n        someTaskUtil.getBuzTask().setJobData(jobData);\r\n        Map<String,Object> map = new HashMap<String,Object>();\r\n        map.put(\"result\",\"change success\");\r\n        return map;\r\n    }\r\n```\r\n\r\n简单的HTML页面 `timeTask.html`：\r\n\r\n```html\r\n<!DOCTYPE HTML>\r\n<html xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <title>修改定时参数</title>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\r\n    <script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"></script>\r\n    <script type=\"text/javascript\" src=\"../static/js/jquery-3.2.1.min.js\"></script>\r\n    <link rel=\"stylesheet\" href=\"bootstrap3.3.7/css/bootstrap.min.css\"\r\n          type=\"text/css\"/>\r\n    <script type=\"text/javascript\">\r\n        $(function() {\r\n        })\r\n    </script>\r\n<body>\r\n<div class=\"panel-body\">\r\n    <form th:action=\"@{'/timeTask/changeCron'}\" method=\"post\" >\r\n        <div class=\"form-group form-inline\">\r\n            <label for=\"txttaskName\" class=\"col-md-3 control-label\"\r\n                   style=\"text-align: right;\">任务名称</label>\r\n            <div class=\"col-md-9\">\r\n                <input type=\"text\" class=\"col-md-9 form-control\" id=\"taskName\" name=\"taskName\"\r\n                       placeholder=\"请输入任务名称\"\r\n                       required=\"required\" />\r\n            </div>\r\n        </div>\r\n        <div class=\"form-group form-inline\" style=\"padding-top:45px\">\r\n            <label for=\"txtcron\" class=\"col-sm-3 control-label\"\r\n                   style=\"text-align: right;\">定时表达式</label>\r\n            <div class=\"col-md-9\">\r\n                <input type=\"text\" class=\"col-sm-9 form-control\" id=\"cron\" name=\"cron\"\r\n                       placeholder=\"请输入定时表达式\"  />\r\n            </div>\r\n        </div>\r\n        <div class=\"form-group form-inline\" style=\"padding-top:45px\">\r\n            <label for=\"txtjobData\" class=\"col-sm-3 control-label\"\r\n                   style=\"text-align: right;\">任务参数</label>\r\n            <div class=\"col-md-9\">\r\n                <input type=\"text\" class=\"col-sm-9 form-control\" id=\"jobData\" name=\"jobData\"\r\n                       placeholder=\"请输入任务参数\"  />\r\n            </div>\r\n        </div>\r\n        <div class=\"form-group\">\r\n            <div class=\"col-md-offset-3 col-md-5\">\r\n                <button class=\"btn btn-primary btn-block\" type=\"submit\" name=\"action\"\r\n                        value=\"login\">执行</button>\r\n            </div>\r\n        </div>\r\n    </form>\r\n</div>\r\n```\r\n\r\n在浏览器输入：`http://localhost:8080/timeTask`\r\n\r\n输入参数：\r\n\r\n```\r\ntaskName ：jobName1\r\ncron ：0/20 * * * * ?\r\njobData ：123\r\n```\r\n\r\n页面返回了 {\"result\":\"change success\"}\r\n\r\n执行结果：\r\n\r\n```txt\r\n jobData : \r\n execute buzz code ...2020-06-25T11:32:50.007\r\n jobData : \r\n execute buzz code ...2020-06-25T11:33:00.001\r\n jobData : \r\n execute buzz code ...2020-06-25T11:33:10.002\r\n jobData : \r\n execute buzz code ...2020-06-25T11:33:20.001\r\n jobData : \r\n execute buzz code ...2020-06-25T11:33:30.002\r\n taskName ：jobName1\r\n cron ：0/20 * * * * ?\r\n jobData ：123\r\n jobData :\r\n execute buzz code ...2020-06-25T11:33:40\r\n jobData ：123\r\n execute buzz code ...2020-06-25T11:34:00.002\r\n jobData ：123\r\n execute buzz code ...2020-06-25T11:34:20.001\r\n jobData ：123\r\n execute buzz code ...2020-06-26T11:34:40.001\r\n```\r\n\r\n原来设置的执行频次是10秒执行一次，jobData是空字符串。\r\n\r\n页面操作之后执行频次是20秒执行一次，jobData值是`123`。\r\n\r\n由此可见，java方法定时的好处，可以动态修改定时任务执行参数。参数可以从数据库拿，也可以在页面及时输入，总之比较灵活。应该适合大多数场景。\r\n\r\n\r\n\r\n\r\n<br/>\r\n\r\n本文整理参考以下前辈链接，放个链接，以示感谢：\r\n\r\n - 参考文章1：https://www.jianshu.com/p/2996afb2c224\r\n - 参考文章2：https://blog.csdn.net/HXNLYW/article/details/88187802\r\n - 参考文章3：https://blog.csdn.net/bjmsb/article/details/105997128\r\n - 参考文章4：https://blog.csdn.net/bjmsb/article/details/105997128
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- docs/pages/Back-end/Java/定时任务/TimeTask-spring-task-1.md	(revision 640356315098df147a918066267421cc14c29e2c)
+++ docs/pages/Back-end/Java/定时任务/TimeTask-spring-task-1.md	(date 1611388367566)
@@ -1,3 +1,4 @@
+<!-- 
 ---
 title: 定时任务之Spring Task
 tags:
@@ -9,7 +10,7 @@
 abbrlink: 5a5ab620
 date: 2020-07-18 22:00:00
 update: 2020-07-18 22:00:00
----
+--- -->
 
 ## 定时任务之Spring Task
 
